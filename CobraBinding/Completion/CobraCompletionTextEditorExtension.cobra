use Cobra.Compiler

use MonoDevelop.CobraBinding.TypeSystem

use MonoDevelop.Core
use MonoDevelop.Projects
use MonoDevelop.Ide.Gui.Content
use MonoDevelop.Ide.CodeCompletion
use MonoDevelop.Ide.TypeSystem

use ICSharpCode.NRefactory.Completion
use ICSharpCode.NRefactory.TypeSystem

namespace MonoDevelop.CobraBinding.Completion

class CobraCompletionTextEditorExtension inherits CompletionTextEditorExtension

	shared
		/#
		These are the previous maps generated by the TypeSystem.Visitor.
		They're used when the current document has parser errors.
		The containing dictionaries are keyed by the document filename.
		#/
		var __prevTypeMap = Dictionary<of String, Dictionary<of ISyntaxNode, Type>>()
		var __prevRegionMap = Dictionary<of String, Dictionary<of ISyntaxNode, DomRegion>>()

		# the various icons that show up next to completion entries
		var iconKeyword = IconId("md-keyword")
		var iconClass = IconId("md-class")
		var iconField = IconId("md-field")
		var iconLiteral = IconId("md-literal")
		var iconMethod = IconId("md-method")
		var iconDelegate = IconId("md-delegate")
		var iconStruct = IconId("md-struct")
		var iconEvent = IconId("md-event")
		var iconProperty = IconId("md-property")
		var iconInterface = IconId("md-interface")
		var iconEnum = IconId("md-enum")
		var iconNamespace = IconId("md-name-space")
		
		var keywordsTopLevel = @[
			"use",
			"namespace",
			"class",
			"interface",
			"struct",
			"mixin",
			"enum",
			"sig",
			"extend",
		]
		
		var keywordsFollowingIs = @[
			"public",
			"protected",
			"private",
			"internal",
			"partial",
			"extern",
			"abstract",
			"override",
		]
		
		var keywordsInBox = @[
			"is",
			"def",
			"var",
			"test",
			"invariant",
			"cue init",
			"var",
			"as",
			"def",
			"pro",
			"get",
			"set",
			
			"class",
			"interface",
			"struct",
			"mixin",
			"enum",
			"sig",
		]
		
		var keywordsInMethod = @[
			"require",
			"ensure",
			"test",
			"body",
			
			"print",
			"lock",
			"using",
			"try",
			"catch",
			"finally",
			"throw",
			"assert",
			"trace",
			"if",
			"and",
			"or",
			"not",
			"in",
			"else",
			"branch",
			"on",
			"for",
			"while",
			"post",
			"return",
		]
		
		var keywordsCobraTypes = @[
			"bool",
			"char",
			"int",
			"uint",
			"float",
			"decimal",
			"number",
			"dynamic"
		]

	def keyPress(key as Gdk.Key, c as char, modifier as Gdk.ModifierType) as bool is override
		"""
		Return true if the key press should be processed by the editor.
		"""
		/#
		trace key
		trace c
		trace modifier
		#/
		return base.keyPress(key, c, modifier)
		
	def handleCodeCompletion(context as CodeCompletionContext?, completionChar as char,
							triggerWordLength as inout int) as ICompletionDataList? is override
		"""
		This method is called indirectly by .keyPress or when the user hits Ctrl+Space.
		"""
		if completionChar == c' '
			return nil
		
		/#
		.document is a MonoDevelop.Ide.Gui.Document
		.document.editor.document is a Mono.TextEditor.Document
		.document.parsedDocument is a MonoDevelop.CobraBinding.TypeSystem.ParsedCobraDocument
		#/
		if context == nil or .document == nil or .document.parsedDocument == nil
			# not enough information to be able to provide completion results
			return nil
			
		line = context.triggerLine
		col = context.triggerLineOffset
		
		textDoc = .document.editor.document
		lineText = textDoc.getLineText(line)
		if String.isNullOrEmpty(lineText), lineText = ""
		
		parsedDoc = .document.parsedDocument to ParsedCobraDocument
		
		# do not provide completion results inside comments
		commentRegions = List<of DomRegion>()
		for fold in parsedDoc.foldings
			if fold.type == FoldType.Comment
				commentRegions.add(fold.region)
		if .getContainingRegions(line, col, commentRegions).count > 0
			return nil
		
		# get code regions from last valid parse tree
		regionMap as Dictionary<of ISyntaxNode, DomRegion>? = nil
		if parsedDoc.regionMap <> nil
			regionMap = parsedDoc.regionMap
			__prevRegionMap[parsedDoc.fileName] = regionMap to !
		else if __prevRegionMap.containsKey(parsedDoc.fileName)
			regionMap = __prevRegionMap[parsedDoc.fileName]
		
		if regionMap == nil
			# not enough information to provide completion
			return nil
		
		# extend code regions to include blank lines and generate a reverse map
		codeRegions = List<of DomRegion>()
		nodeMap = Dictionary<of DomRegion, ISyntaxNode>()
		for node, region in regionMap to !
			extendedRegion = _extendRegion(region)
			codeRegions.add(extendedRegion)
			nodeMap[extendedRegion] = node
			
		for extendedRegion, node in nodeMap
			regionMap[node] = extendedRegion
		
		__prevRegionMap[parsedDoc.fileName] = regionMap to !
		
		containingRegions = .getContainingRegions(line, col, codeRegions)
		completionData = CompletionDataList()
		
		if completionChar == c'.'
			# return fields and methods in the context of the current class
			for region in containingRegions
				node = nodeMap[region]
				if node inherits Class
					completionData.addRange(_getClassMemberCompletionData(node))
			return completionData
			
		else if completionChar <> c' '
			# do this so that the letter just typed is considered part of the word to complete 
			triggerWordLength += 1
			col -= 1
			
		if col < 0
			# this can happen on manual triggering of code completion via Ctrl+Space from the start of a blank line
			col = 0
											
		if containingRegions.count == 0
			return _getTopLevelCompletionData(lineText.substring(0, col), "TODO")
				
		else
			# return unique completion data entries
			dataSet = HashSet<of String>()
			uniqueData = List<of ICompletionData>()
			for region in containingRegions
				for d in _getCompletionData(region, lineText.substring(0, col), "TODO")
					if dataSet.add(d.toString)
						uniqueData.add(d)
			
			# add identifiers
			#TODO: be smarter about this
			typeMap as Dictionary<of ISyntaxNode, Type>? = nil
			if parsedDoc.typeMap <> nil
				typeMap = parsedDoc.typeMap
				__prevTypeMap[parsedDoc.fileName] = typeMap to !
			else if __prevTypeMap.containsKey(parsedDoc.fileName)
				typeMap = __prevTypeMap[parsedDoc.fileName]
			
			if typeMap <> nil
				for node in typeMap.keys
					if node.getType == NameSpace
						for d in _getNamespaceCompletionData(node to NameSpace)
							if dataSet.add(d.toString)
								uniqueData.add(d)
					if node.getType == Class
						for d in _getClassMemberCompletionData(node to Class)
							if dataSet.add(d.toString)
								uniqueData.add(d)
					if node.getType == AbstractMethod
						for d in _getMethodVarCompletionData(node to AbstractMethod)
							if dataSet.add(d.toString)
								uniqueData.add(d)
					else
						pass
						
			completionData.addRange(uniqueData)
			return completionData
			
		return nil

	def handleParameterCompletion(context as CodeCompletionContext?, completionChar as char) _
		as IParameterDataProvider? is override

		return nil

	def getContainingRegions(line as int, col as int, regions as DomRegion*) as List<of DomRegion>
		"""
		Returns a list of document regions from the given region stream that contain the 
		given document location.
		"""
		ensure # we'll never return more regions than what was given
			result.count <= List<of DomRegion>(regions).count
		test
			rs = List<of DomRegion>()
			rs.add(DomRegion(1, 1, 10, 120))
			rs.add(DomRegion(1, 1, 5, 120))
			rs.add(DomRegion(6, 1, 10, 120))
			rs.add(DomRegion(11, 1, 15, 120))
			rs.add(DomRegion(12,1, 14, 120))

			complExt = CobraCompletionTextEditorExtension()
			assert complExt.getContainingRegions(1, 1, rs).count == 2
			assert complExt.getContainingRegions(2, 1, rs).count == 2
			assert complExt.getContainingRegions(5, 80, rs).count == 2
			assert complExt.getContainingRegions(6, 10, rs).count == 2
			assert complExt.getContainingRegions(11, 1, rs).count == 1
			assert complExt.getContainingRegions(13, 1, rs).count == 2
			assert complExt.getContainingRegions(15, 20, rs).count == 1
			assert complExt.getContainingRegions(16, 1, rs).count == 0
		body
			containingRegions = List<of DomRegion>()
			for r in regions
				if r.isInside(line, col)
					containingRegions.add(r)
			return containingRegions
			
			
	def _extendRegion(region as DomRegion) as DomRegion
		"""
		Returns a copy of the given region but extends the last line
		to include all blank lines that immediately follow it.
		"""
		require
			.document.editor.document <> nil
			region.beginLine > 0
			region.endLine <= .document.editor.document.lineCount
		ensure
			result.beginLine == region.beginLine
			result.endLine >= region.endLine
		body
			textDoc = .document.editor.document
			
			# extend the given region to encompass at least its own last line
			extendedRegion = DomRegion(region.fileName, _
				region.beginLine, region.beginColumn, _
				region.endLine, textDoc.getLineText(region.endLine).length)
		
			fromLine = region.endLine + 1
			untilLine = textDoc.lineCount + 1
			for line in fromLine:untilLine
				text = textDoc.getLineText(line)
				if text <> nil and text.trim.length > 0
					break
			
			if line < untilLine
				extendedRegion = DomRegion(region.fileName, _
				region.beginLine, region.beginColumn, _
				line, 0)
			
			return extendedRegion

	def _getIndentLevel(line as String) as int
		"""
		Returns the number of indents for the given line.
		"""
		# Crap!  This function already exists in Parser.  Shouldn't be repeated here.
		return line.length - line.trimStart.length

	def _getTopLevelCompletionData(preceedingText as String, currText as String) as ICompletionDataList
		"""
		Returns completion data when we are in the context of a namespace and can
		declare classes, interfaces, etc.
		
		TODO: Use RegEx's instead of crossing our fingers and using string literals
		"""
		dataList = CompletionDataList()
		if preceedingText.endsWith("use ")
			# provide namespaces from explicit references
			dataList.addRange(_getNamespacesFromProjectRefs)
			
		else if preceedingText.trim.length == 0
			for kw in .keywordsTopLevel
				dataList.add(kw, .iconKeyword)
			
		else if preceedingText.endsWith(" is ")
			for kw in .keywordsFollowingIs
				dataList.add(kw, .iconKeyword)
				
		else if preceedingText.endsWith(" as ")
			for kw in .keywordsCobraTypes
				dataList.add(kw, .iconKeyword)
			#TODO: return all types from explicit and implicit references
		
		else if preceedingText.endsWith(" inherits ")
			#TODO: return class names
			pass
			
		else if preceedingText.endsWith(" implements ")
			#TODO: return interface names
			pass
			
		else if preceedingText.endsWith(" adds ")
			#TODO: return mixin names
			pass
			
		else if preceedingText.endsWith(" has ")
			#TODO: return attribute names
			pass
			
		else
			#TODO: finer context
			dataList.add("adds", .iconKeyword)
			dataList.add("inherits", .iconKeyword)
			dataList.add("implements", .iconKeyword)
			dataList.add("has", .iconKeyword)
			dataList.add("is", .iconKeyword)
			
		return dataList

	def _getCompletionData(region as DomRegion, preceedingText as String, currText as String) as ICompletionDataList
		"""
		Returns completion data in the context of the given DomRegion.
		"""
		require
			.document.editor <> nil
			.document.editor.document <> nil
		body
			dataList = CompletionDataList()
			textDoc = .document.editor.document
			firstRegionLine = textDoc.getLineText(region.beginLine).trimStart
			if firstRegionLine.startsWith("namespace ")
				#TODO being inside a namespace means we have access to all the classes inside of it
				dataList.addRange(_getTopLevelCompletionData(preceedingText, currText))
				
			else if firstRegionLine.startsWith("class ")
				#TODO being inside a class gives us access to all its fields and methods
				for kw in .keywordsInBox
					dataList.add(kw, .iconKeyword)
				
			else if firstRegionLine.startsWith("def ") or firstRegionLine.startsWith("get ") or firstRegionLine.startsWith("set ")
				#TODO being inside a method gives us access to all its local variables and also to a lot more Cobra keywords
				for kw in .keywordsInMethod
					dataList.add(kw, .iconKeyword)
				
			return dataList

	def _getNamespacesFromProjectRefs as ICompletionDataList
		"""
		Returns the namespaces of the types in the current project references
		"""
		#TODO do it right with only one namespace level at as time
		nsList = List<of String>()
		
		proj = .document.project to DotNetProject
		for r in proj.references
			for asmFileName in r.getReferencedFileNames(DefaultConfigurationSelector())
				try
					asm = System.Reflection.Assembly.loadFile(asmFileName)
					if asm <> nil
						for t in asm.getTypes
							if t.namespace <> nil and t.namespace not in nsList
								nsList.add(t.namespace)
				catch ex as Exception
					# failed to load assembly, just ignore it for now
					trace ex.message
		
		dataList = CompletionDataList()
		
		for ns in nsList
			dataList.add(ns, .iconNamespace)
		
		return dataList
		
	def _getNamespaceCompletionData(n as NameSpace) as ICompletionDataList
		"""
		Given a namespace node, return the namespaces and types it provides.
		"""
		
		decls = CompletionDataList()
		
		for d in n.declsInOrder
			if d inherits Class
				decls.add(d.name, .iconClass)
			else if d inherits MethodSig
				decls.add(d.name, .iconDelegate)
			else if d inherits Struct
				decls.add(d.name, .iconStruct)
			else if d inherits Interface
				decls.add(d.name, .iconInterface)
			else if d inherits NameSpace
				decls.add(d.name, .iconNamespace)
			else if d inherits EnumDecl
				decls.add(d.name, .iconEnum)
						
		return decls
		
	def _getClassMemberCompletionData(c as Class) as ICompletionDataList
		"""
		Given a class node, return the members associated with it.
		"""
		
		decls = CompletionDataList()
		
		for d in c.declsInOrder
			if d inherits AbstractMethod
				decls.add(d.name, .iconMethod)
			else
				decls.add(d.name, .iconField)
		
		return decls
		
	def _getMethodVarCompletionData(m as AbstractMethod) as ICompletionDataList
		"""
		Given a method node, return the local variables associated with it.
		"""
		
		vars = CompletionDataList()
		
		for v in m.locals
			vars.add(v.name)
		
		return vars
