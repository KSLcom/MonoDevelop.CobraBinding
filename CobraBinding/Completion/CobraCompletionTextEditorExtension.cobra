use System.Text.RegularExpressions

use Cobra.Compiler

use MonoDevelop.CobraBinding.TypeSystem

use MonoDevelop.Core
use MonoDevelop.Projects
use MonoDevelop.Ide
use MonoDevelop.Ide.Gui.Content
use MonoDevelop.Ide.CodeCompletion
use MonoDevelop.Ide.TypeSystem

use ICSharpCode.NRefactory.Completion
use ICSharpCode.NRefactory.TypeSystem


namespace MonoDevelop.CobraBinding.Completion

class CobraCompletionTextEditorExtension inherits CompletionTextEditorExtension

	# these are for indexing into the lists contained in the values of the _icons dictionary
	const _defaultIcon = 0
	const _protectedIcon = 1
	const _privateIcon = 2
	const _internalIcon = 3

	shared
		/#
		This is the previous map generated by the TypeSystem.Visitor.
		It's used when the current document has parser errors.
		The containing dictionary is keyed by the document filename.
		#/
		var __prevRegionMap = Dictionary<of String, _
			Dictionary<of ISyntaxNode, DomRegion>>()

		# likewise with the previous symbol table
		var __prevSymbolTable = Dictionary<of String, _
			Dictionary<of DomRegion, Dictionary<of String, INamedNode>?>>()
		
		# The various icons that show up next to completion entries.
		var _icons as Dictionary<of Type, List<of IconId>> = {
			Keyword : [IconId("md-keyword")],
			Literal : [Gui.Stock.literal],
			NameSpace : [Gui.Stock.nameSpace],
			EnumDecl : [Gui.Stock.enum, Gui.Stock.protectedEnum, Gui.Stock.privateEnum, Gui.Stock.internalEnum],
			Struct : [Gui.Stock.struct, Gui.Stock.protectedStruct, Gui.Stock.privateStruct, Gui.Stock.internalStruct],
			Interface : [Gui.Stock.interface, Gui.Stock.protectedInterface, Gui.Stock.privateInterface, Gui.Stock.internalInterface],
			Class : [Gui.Stock.class, Gui.Stock.protectedClass, Gui.Stock.privateClass, Gui.Stock.internalClass],
			BoxVar : [Gui.Stock.field, Gui.Stock.protectedField, Gui.Stock.privateField, Gui.Stock.internalField],
			BoxConst : [Gui.Stock.literal],
			Method : [Gui.Stock.method, Gui.Stock.protectedMethod, Gui.Stock.privateMethod, Gui.Stock.internalMethod],
			LocalVar : [Gui.Stock.field],
			MethodSig : [Gui.Stock.delegate, Gui.Stock.protectedDelegate, Gui.Stock.privateDelegate, Gui.Stock.internalDelegate],
			Property : [Gui.Stock.property, Gui.Stock.protectedProperty, Gui.Stock.privateProperty, Gui.Stock.internalProperty],
			BoxEvent : [Gui.Stock.event, Gui.Stock.protectedEvent, Gui.Stock.privateEvent, Gui.Stock.internalEvent]
			#TODO: AttributeDecl, Mixin, Extension, TestMethod, contracts, etc.
		}
		
		var _iconKeyword = _icons[Keyword][_defaultIcon]
		var _iconLiteral = _icons[Literal][_defaultIcon]
		var _iconNameSpace = _icons[NameSpace][_defaultIcon]
		var _iconLocalVar = _icons[LocalVar][_defaultIcon]
		var _iconError = Gui.Stock.error
		
		def getStockIcon(node as dynamic) as IconId
			"""
			Returns the icon that should be used for the
			CompletionDataList entry for the given node.
			"""
			try
				listOfIcons = _icons[node.getType]
			catch
				# not handled yet
				trace node.getType
				return _iconError
		
			try
				if "internal" in node.isNames
					return listOfIcons[_internalIcon]
				else if "private" in node.isNames
					return listOfIcons[_privateIcon]
				else if "protected" in node.isNames
					return listOfIcons[_protectedIcon]
				else
					return listOfIcons[_defaultIcon]
			catch
				return listOfIcons[_defaultIcon]
		
		var _keywordsTopLevel = @[
			"use",
			"namespace",
			"class",
			"interface",
			"struct",
			"mixin",
			"enum",
			"sig",
			"extend",
			"adds",
			"inherits",
			"implements",
			"has",
			"is",
		]
		
		var _keywordsFollowingIs = @[
			"public",
			"protected",
			"private",
			"internal",
			"partial",
			"extern",
			"abstract",
			"override",
		]
		
		var _keywordsInBox = @[
			"is",
			"def",
			"var",
			"test",
			"invariant",
			"cue init",
			"var",
			"as",
			"def",
			"pro",
			"get",
			"set",
			
			"class",
			"interface",
			"struct",
			"mixin",
			"enum",
			"sig",
		]
		
		var _keywordsInMethod = @[
			"require",
			"ensure",
			"test",
			"body",
			
			"print",
			"lock",
			"using",
			"try",
			"catch",
			"finally",
			"throw",
			"assert",
			"trace",
			"if",
			"and",
			"or",
			"not",
			"in",
			"else",
			"branch",
			"on",
			"for",
			"while",
			"post",
			"return",
		]
		
		var _keywordsCobraTypes = @[
			"bool",
			"char",
			"int",
			"uint",
			"float",
			"decimal",
			"number",
			"dynamic"
		]
		
		var _keywordsLiterals = @[
			"true",
			"false",
			"nil"
		]
		
		var _charsToIgnore = @[
			c',',
			c')',
			c'[',
			c']',
			c'"',
			c"'",
		]
		#' TODO: handle the case above in CobraSyntaMode.xml
	
	
	get regionMap as Dictionary<of ISyntaxNode, DomRegion>
		"""
		Return code regions from last valid AST.
		Values are keyed by the declaring syntax node.
		"""
		require
			.document <> nil
			.document.parsedDocument <> nil
			.document.parsedDocument inherits ParsedCobraDocument
		body
			parsedDoc = .document.parsedDocument to ParsedCobraDocument
			
			map = parsedDoc.regionMap
			
			if map <> nil
				# save this for next time
				__prevRegionMap[parsedDoc.fileName] = map
				return map
				
			else if __prevRegionMap.containsKey(parsedDoc.fileName)
				# current parsed document has errors
				return __prevRegionMap[parsedDoc.fileName]
			
			# just return an empty dictionary
			return Dictionary<of ISyntaxNode, DomRegion>()
	
	
	get symbolTable as Dictionary<of DomRegion, Dictionary<of String, INamedNode>?>
		"""
		Return the symbol table from last valid AST.
		Values are nilable dictionaries mapping identifiers	to
		their corresponding nodes and are keyed by code region.
		"""
		require
			.document <> nil
			.document.parsedDocument <> nil
			.document.parsedDocument inherits ParsedCobraDocument
		body
			parsedDoc = .document.parsedDocument to ParsedCobraDocument
			
			table = parsedDoc.symbolTable
			
			if table <> nil
				# save this for next time
				__prevSymbolTable[parsedDoc.fileName] = table
				return table
				
			else if __prevSymbolTable.containsKey(parsedDoc.fileName)
				# current parsed document has errors
				return __prevSymbolTable[parsedDoc.fileName]
			
			# just return an empty dictionary
			return Dictionary<of DomRegion, Dictionary<of String, INamedNode>?>()
	
	
	def _canHandleCodeCompletion(context as CodeCompletionContext?, completionChar as char) as bool
		"""
		Returns true if the extension is able to provide completion results in the given
		context for the given completion character or false otherwise.
		"""
		if completionChar in _charsToIgnore
			return false
			
		# .document is a MonoDevelop.Ide.Gui.Document
		# .document.parsedDocument is a MonoDevelop.CobraBinding.TypeSystem.ParsedCobraDocument
		if context == nil _
		or .document == nil _
		or .document.parsedDocument == nil _
		or .editor == nil
			return false

		if _isInsideComment(context)
			return false
			
		parsedDoc = .document.parsedDocument to ParsedCobraDocument
		if parsedDoc.regionMap == nil and not __prevRegionMap.containsKey(parsedDoc.fileName)
			return false
			
		if parsedDoc.symbolTable == nil and not __prevSymbolTable.containsKey(parsedDoc.fileName)
			return false
	
		return true
	
	def handleCodeCompletion(context as CodeCompletionContext?, completionChar as char,
							triggerWordLength as inout int) as ICompletionDataList? is override
		"""
		This method is called indirectly by .keyPress or when the user hits Ctrl+Space.
		"""

		if not _canHandleCodeCompletion(context, completionChar)
			# not enough information to provide completion results
			return nil

		if completionChar == c'('
			#TODO handle parameter completion
			return nil
		
		# get code regions and symbol table from last valid AST
		regionMap = .regionMap
		symbolTable = .symbolTable
		
		# extend code regions to include blank lines
		_extendRegions(regionMap, symbolTable)
		
		# generate a reverse map (regions to nodes)
		nodeMap = _createNodeMap(regionMap)

		line = context.triggerLine
		col = context.triggerLineOffset
		
		lineText = .editor.document.getLineText(line) ? ""

		containingRegions = .getContainingRegions(line, col, regionMap.values)
		completionData = CompletionDataList()
		preceedingText = lineText.substring(0, .editor.caret.column - 1)

		if completionChar == c'.'
			# member completion

			# don't include the dot or anything before it in the trigger word length
			triggerWordLength = 0

			ids = _getIdsFromText(preceedingText)

			if ids.count == 0
				# return fields and methods in the context of the current class
				for region in containingRegions
					node = nodeMap[region]
					if node inherits Class
						completionData.addRange(_getBoxMemberCompletionData(node))
				return completionData
			else
				# return fields and methods for the corresponding node
				try
					node = _getNodeFromIds(ids, containingRegions, symbolTable)

					if node inherits AbstractLocalVar
						if node.type inherits Box
							completionData.addRange(_getBoxMemberCompletionData(node.type to Box))
					else if node inherits NameSpace
						completionData.addRange(_getNamespaceCompletionData(node))
					else if node implements Cobra.Compiler.IMember
						if node.resultType inherits Box
							completionData.addRange(_getBoxMemberCompletionData(node.resultType to Box))
					
					print "should be displaying members for [node]"

					return completionData
				catch ArgumentException
					# not a valid identifier
					return nil
					
		else if completionChar <> c' '
			# do this so that the letter just typed is considered part of the word to complete
			while col > 1 and lineText[col - 1] not in @[c'\t', c' ']
				triggerWordLength += 1
				col -= 1

		# return unique completion data entries
		dataSet = HashSet<of String>()
		uniqueData = List<of ICompletionData>()

		for region in containingRegions
			for d in _getCompletionData(region, preceedingText, "TODO", nodeMap)
				if dataSet.add(d.toString)
					uniqueData.add(d)

		completionData.addRange(uniqueData)

		if completionData.count <> 0
			return completionData
		else
			return nil


	def handleParameterCompletion(context as CodeCompletionContext?, completionChar as char) _
		as IParameterDataProvider? is override

		return nil
	
	def _isInsideComment(context as CodeCompletionContext) as bool
		"""
		Returns true if the cursor is inside a comment region.
		"""
		line = context.triggerLine
		col = context.triggerLineOffset
		if line < 1, line = 1
		if col < 0, col = 0
		
		lineText = .editor.document.getLineText(line) ? ""
		
		return _isInsideComment(line, col, lineText, .document.parsedDocument.foldings)
	
	def _isInsideComment(line as int, col as int, lineText as String, foldings as IEnumerable<of FoldingRegion>) as bool
		"""
		Returns true if the cursor is inside a comment region.
		"""
		require
			line > 0
			col >= 0
		test lineComment
			ext = CobraCompletionTextEditorExtension()
			folds = List<of FoldingRegion>()
			assert ext._isInsideComment(1, 0, "# comment", folds)
			assert ext._isInsideComment(1, 1, "# comment", folds)
			assert ext._isInsideComment(1, 15, "print 'hello' # comment", folds)
		test commentBlock
			ext = CobraCompletionTextEditorExtension()
			folds = List<of FoldingRegion>()
			folds.add(FoldingRegion(DomRegion(1, 1, 4, 1), FoldType.Comment))
			assert ext._isInsideComment(2, 1, "print '#hello#'", folds)
			folds.add(FoldingRegion(DomRegion(1, 1, 3, 1), FoldType.Undefined))
			assert ext._isInsideComment(2, 0, "print '#hello#'", folds)
		test notInComment
			ext = CobraCompletionTextEditorExtension()
			folds = List<of FoldingRegion>()
			assert not ext._isInsideComment(1, 0, "print 'hello' # comment", folds)
			assert not ext._isInsideComment(1, 1, "print 'hello' # comment", folds)
			assert not ext._isInsideComment(1, 10, "print '#hello#'", folds)
			folds.add(FoldingRegion(DomRegion(3, 1, 4, 1), FoldType.Comment))
			assert not ext._isInsideComment(1, 1, "print 'hello' # comment", folds)
			folds.add(FoldingRegion(DomRegion(1, 1, 2, 1), FoldType.Undefined))
			assert not ext._isInsideComment(1, 0, "print 'hello' # comment", folds)
		body
			if lineText.length > 0
				
				if lineText.trimStart.startsWith("#")
					return true
				
				inString = false
				stringDelim as char? = nil
				
				for i in 0:col
					c = lineText[i]
					if c == c'"' or c == c"'"
						if stringDelim == nil
							stringDelim = c
							inString = true
						else if stringDelim == c
							stringDelim = nil
							inString = false
					if c == c'#' and not inString
						return true
				
			for fold in foldings
				if fold.type == FoldType.Comment and fold.region.isInside(line, col)
					return true
				
			return false
	
	
	def _createNodeMap(regionMap as Dictionary<of ISyntaxNode, DomRegion>) as Dictionary<of DomRegion, ISyntaxNode>
		"""
		Returns a map of DomRegions to ISyntaxNodes given a map of ISyntaxNodes to DomRegions.
		"""
		ensure
			all for node in regionMap.keys get node in result.values
			all for region in regionMap.values get region in result.keys
		body
			nodeMap = Dictionary<of DomRegion, ISyntaxNode>()
			for node, region in regionMap
				nodeMap[region] = node
			return nodeMap
	

	def getContainingRegions(line as int, col as int, regions as DomRegion*) as List<of DomRegion>
		"""
		Returns a list of document regions from the given region stream that contain the 
		given document location.
		"""
		ensure # we'll never return more regions than what was given
			result.count <= List<of DomRegion>(regions).count
		test
			rs = List<of DomRegion>()
			rs.add(DomRegion(1, 1, 10, 120))
			rs.add(DomRegion(1, 1, 5, 120))
			rs.add(DomRegion(6, 1, 10, 120))
			rs.add(DomRegion(11, 1, 15, 120))
			rs.add(DomRegion(12,1, 14, 120))

			complExt = CobraCompletionTextEditorExtension()
			assert complExt.getContainingRegions(1, 1, rs).count == 2
			assert complExt.getContainingRegions(2, 1, rs).count == 2
			assert complExt.getContainingRegions(5, 80, rs).count == 2
			assert complExt.getContainingRegions(6, 10, rs).count == 2
			assert complExt.getContainingRegions(11, 1, rs).count == 1
			assert complExt.getContainingRegions(13, 1, rs).count == 2
			assert complExt.getContainingRegions(15, 20, rs).count == 1
			assert complExt.getContainingRegions(16, 1, rs).count == 0
		body
			containingRegions = List<of DomRegion>()
			for r in regions
				if r.isInside(line, col)
					containingRegions.add(r)

			return containingRegions
		
		
	def _extendRegions(regionMap as Dictionary<of ISyntaxNode, DomRegion>,
						symbolTable as Dictionary<of DomRegion, Dictionary<of String, INamedNode>?>)
		"""
		Extends the code regions in the given dictionaries to include blank lines.
		"""
		extendedRegionMap = Dictionary<of ISyntaxNode, DomRegion>()
		
		for node, region in regionMap
			
			extendedRegion = _extendRegion(region)
			extendedRegionMap[node] = extendedRegion
			
			idMap as Dictionary<of String, INamedNode>? = nil
			if symbolTable.tryGetValue(region, out idMap)
				symbolTable.remove(region)
				symbolTable[extendedRegion] = idMap
				
		for node, extendedRegion in extendedRegionMap
			regionMap[node] = extendedRegion
			
			
	def _extendRegion(region as DomRegion) as DomRegion
		"""
		Returns a copy of the given region but extends the last line
		to include all blank lines that immediately follow it.
		
		The ending point will be the 0th column of the first non-blank
		line.
		"""
		require
			.document.editor.document <> nil
			region.beginLine > 0
		ensure
			result.beginLine == region.beginLine
			result.endLine >= region.endLine
		body
			textDoc = .document.editor.document
			fromLine = region.endLine + 1
			untilLine = textDoc.lineCount + 1
			
			for line in fromLine:untilLine
				text = textDoc.getLineText(line)
				if text <> nil and text.trim.length > 0
					break
			
			extendedRegion = DomRegion(region.fileName, _
			region.beginLine, region.beginColumn, _
			line, 0)
			
			return extendedRegion

	def _getIndentLevel(line as String) as int
		"""
		Returns the number of indents for the given line.
		"""
		# Crap!  This function already exists in Parser.  Shouldn't be repeated here.
		return line.length - line.trimStart.length


	shared
		var rexIdentifier = Regex( _
			r'[_a-zA-z0-9]*', _
			RegexOptions.Compiled _
		)

	def _getIdsFromText(text as String) as List<of String>
		"""
		Given a line of text, returns a list of trailing identifiers.

		For example, given "foo = SomeSharedClass.someProp.", then this
		method would return ['SomeSharedClass', 'someProp'].
		"""
		test
			sampleText = "foo = SomeSharedClass.someProp."
			completionExtension = CobraCompletionTextEditorExtension()
			ids = completionExtension._getIdsFromText(sampleText)
			assert ids.count == 2
			assert ids[0] == "SomeSharedClass"
			assert ids[1] == "someProp"
		body
			ids = List<of String>()
			text = text.trim

			# split the text by whitespace
			pieces = text.split
			lastPiece = pieces[pieces.length - 1]

			match = CobraCompletionTextEditorExtension.rexIdentifier.match(lastPiece)
			while match.success
				if match.value.length > 0
					ids.add(match.value)
				match = match.nextMatch to !

			return ids

	def _getNodeFromIds(ids as List<of String>,
						containingRegions as List<of DomRegion>,
						symbolTable as Dictionary<of DomRegion, Dictionary<of String, INamedNode>>) as ISyntaxNode
		"""
		Given a list of identifiers, returns the syntax node in the AST
		corresponding to the last valid idenfiier.

		Throws an ArgumentException if no node is found.
		"""
		require
			ids.count > 0
			containingRegions.count > 0

		test singleIdentifier
			# setup
			ids = ['Object']
			regions = [DomRegion(1,1)]
			bogusNode = Class('Object', List<of Cobra.Compiler.IType>())
			symbolTable = Dictionary<of DomRegion, Dictionary<of String, INamedNode>>()
			symbolTable[regions[0]] = Dictionary<of String, INamedNode>()
			symbolTable[regions[0]]['Object'] = bogusNode

			# the test
			completionExtension = CobraCompletionTextEditorExtension()
			assert completionExtension._getNodeFromIds(ids, regions, symbolTable) is bogusNode
			
		test multipleIdentifiers
			#TODO
			# setup
			# the test
			pass

		body
			#TODO: still feels ugly...
			correspondingNode as ISyntaxNode? = nil
			idMap as Dictionary<of String, INamedNode>? = nil

			for region in containingRegions
				
				found = false

				if symbolTable.tryGetValue(region, out idMap)
				
					for id, node in idMap
					
						if id == ids[0]
							correspondingNode = node to ISyntaxNode
							found = true
							break
							
					if found, break
				if found, break
			
			if found
				# we found a node with this name, limit the rest of our search to this node
				try
					return _getNodeFromIds(ids[1:ids.count], correspondingNode)
				catch
					return correspondingNode to !
					
			throw ArgumentException()
			
	def _getNodeFromIds(ids as List<of String>, parent as ISyntaxNode) as ISyntaxNode
		"""
		Given a list of identifiers, returns the syntax node in the AST
		corresponding to the last valid idenfiier.

		Throws an ArgumentException if no node is found.
		"""
		if ids.count == 0
			return parent
		
		if parent implements INamedNode
		
			if parent.typeForReceiver implements IContainer
		
				t = parent.typeForReceiver
		
				if t inherits NameSpace
					for useDirective in t.useDirectives
						if useDirective.boundNameSpace <> nil
							nsMember = useDirective.boundNameSpace.memberForName(ids[0])
							if nsMember <> nil
								try
									return _getNodeFromIds(ids[1:ids.count], nsMember to ISyntaxNode)
								catch
									throw ArgumentException()
		
				m = t.memberForName(ids[0])
				if m <> nil
					try
						return _getNodeFromIds(ids[1:ids.count], m to ISyntaxNode)
					catch
						throw ArgumentException()
			else
				print "[parent.typeForIdentifier.name] does not implement IContainer"
		
		throw ArgumentException()
				
			
	def _getTopLevelCompletionData(preceedingText as String, currText as String) as ICompletionDataList
		"""
		Returns completion data when we are in the context of a namespace and can
		declare classes, interfaces, etc.
		
		TODO: Use RegEx's instead of crossing our fingers and using string literals
		"""
		
		dataList = CompletionDataList()
		if preceedingText.endsWith("use ")
			# provide namespaces from explicit references
			dataList.addRange(_getNamespacesFromProjectRefs)
			
		else if preceedingText.endsWith(" is ")
			for kw in _keywordsFollowingIs
				dataList.add(kw, _iconKeyword)
				
		else if preceedingText.endsWith(" as ") or preceedingText.endsWith(" = ")
			for kw in _keywordsCobraTypes
				dataList.add(kw, _iconKeyword)
				
			for kw in _keywordsLiterals
				dataList.add(kw, _iconLiteral)
			
			# return all imported decls
			dataList.addRange(_getAvailableDecls)
		
		else if preceedingText.endsWith(" inherits ")
			#TODO: return class names
			pass
			
		else if preceedingText.endsWith(" implements ")
			#TODO: return interface names
			pass
			
		else if preceedingText.endsWith(" adds ")
			#TODO: return mixin names
			pass
			
		else if preceedingText.endsWith(" has ")
			#TODO: return attribute names
			pass
			
		else
			#TODO finer context
			for kw in _keywordsTopLevel
				dataList.add(kw, _iconKeyword)
		
		return dataList

	def _getCompletionData(region as DomRegion, preceedingText as String, currText as String,
							nodeMap as Dictionary<of DomRegion, ISyntaxNode>) as ICompletionDataList
		"""
		Returns completion data in the context of the given DomRegion.
		"""
		require
			.document.editor <> nil
			.document.editor.document <> nil
		body
			dataList = CompletionDataList()
			dataList.addRange(_getTopLevelCompletionData(preceedingText, currText))
			
			textDoc = .document.editor.document
			firstRegionLine = textDoc.getLineText(region.beginLine).trimStart
			
			if firstRegionLine.startsWith("namespace ")
				# being inside a namespace means we have access to all the classes inside of it
				dataList.addRange(_getNamespaceCompletionData(nodeMap[region] to NameSpace))
				
			else if firstRegionLine.startsWith("class ") and nodeMap[region] inherits Class
				/#
				Implicit class initializers would also fall into this block if we didn't check
				to make sure that the node inherits from 'Class.'
				#/
			
				# being inside a class gives us access to all its fields and methods
				for kw in _keywordsInBox
					dataList.add(kw, _iconKeyword)
				
				dataList.addRange(_getBoxMemberCompletionData(nodeMap[region] to Class))
				
			else if firstRegionLine.startsWith("def ") or firstRegionLine.startsWith("get ") or firstRegionLine.startsWith("set ")
				# being inside a method gives us access to all its local variables and more Cobra keywords
				for kw in _keywordsInMethod
					dataList.add(kw, _iconKeyword)
				
				if firstRegionLine.startsWith("def ")
					dataList.addRange(_getMethodVarCompletionData(nodeMap[region] to AbstractMethod))
			
			return dataList

	def _getNamespacesFromProjectRefs as ICompletionDataList
		"""
		Returns the namespaces of the types in the current project references
		"""
		#TODO do it right with only one namespace level at as time
		nsList = List<of String>()
		dataList = CompletionDataList()
		
		proj = .document.project to DotNetProject?
		if proj == nil
			/# This can happen if we are working on a single file
			that is not part of a project #/
			return dataList
		
		for r in proj.references
			for asmFileName in r.getReferencedFileNames(DefaultConfigurationSelector())
				try
					asm = System.Reflection.Assembly.loadFile(asmFileName)
					if asm <> nil
						for t in asm.getTypes
							if t.namespace <> nil and t.namespace not in nsList
								nsList.add(t.namespace)
				catch ex as Exception
					# failed to load assembly, just ignore it for now
					print ex.message
		
		for ns in nsList
			dataList.add(ns, _iconNameSpace)
		
		return dataList
		
	def _getAvailableDecls as ICompletionDataList
		"""
		Returns all declarations visible in the current context.
		"""
		require
			.document
			.document.parsedDocument
		body
			dataList = CompletionDataList()
			ast as CobraModule? = .document.parsedDocument.getAst<of CobraModule>
			if ast == nil
				return dataList
			
			dataList.addRange(_getNamespaceCompletionData(ast.topNameSpace))
			
			for useStmt in ast.topNameSpace.useDirectives
				if useStmt.boundNameSpace <> nil
					ns = useStmt.boundNameSpace to !
					dataList.addRange(_getNamespaceCompletionData(ns))
			
			return dataList
		
		
	def _getNamespaceCompletionData(n as NameSpace) as ICompletionDataList
		"""
		Given a namespace node, return the namespaces and types it provides.
		"""
		decls = CompletionDataList()
		
		if n.name.startsWith('(')
			# an unnamed top-level namespace for a module
			nsNamePrefix = ""
		else
			nsNamePrefix = n.name + "."
		
		for d in n.declsInOrder
			icon = .getStockIcon(d)
		
			if d inherits NameSpace or d inherits EnumDecl
				decls.add(d.name, icon, nsNamePrefix + d.name)
			else if d inherits Box
				decls.add(d.name, icon, d.qualifiedName)
		
		return decls
		
		
	def _getBoxMemberCompletionData(b as Box) as ICompletionDataList
		"""
		Given a box node, return the unique members associated with it.
		"""
		seen = HashSet<of String>()
		
		# pretend we've already seen 'cue.init' so it's not included in the final list
		seen.add("cue.init")
		
		members = CompletionDataList()

		#TODO: clean this up
		for m in b.declsInOrder
			if seen.add(m.name)
				
				icon = .getStockIcon(m)
				
				try
					if m inherits Box
						members.add(m.name, icon, m.qualifiedName)
					else if m inherits AbstractMethod
						members.add(m.name, icon, m.resultType.name)
					else if m inherits BoxEvent
						members.add(m.name, icon, m.resultType.name)
					else if m inherits Property
						members.add(m.name, icon, m.resultType.name)
					else if m inherits BoxVar
						members.add(m.name, icon, m.type.name)
					else if m inherits BoxConst
						members.add(m.name, icon, m.type.name)
					else
						members.add(m.name, icon, m.getType.name)
				catch
					if m inherits Box
						members.add(m.name, icon, "Failed to evaluate 'm.qualifiedName'")
					else if m inherits AbstractMethod
						members.add(m.name, icon, "Failed to evaluate 'm.resultType.name'")
					else if m inherits BoxEvent
						members.add(m.name, icon, "Failed to evaluate 'm.resultType.name'")
					else if m inherits Property
						members.add(m.name, icon, "Failed to evaluate 'm.resultType.name'")
					else if m inherits BoxVar
						members.add(m.name, icon, "Failed to evaluate 'm.type.name'")
					else if m inherits BoxConst
						members.add(m.name, icon, "Failed to evaluate 'm.type.name'")
					else
						members.add(m.name, icon, "Failed to evaluate 'm.getType.name'")
		
		try
			for m in b.allMembers
				if seen.add(m.name)
				
					icon = .getStockIcon(m)
				
					if m inherits Box
						members.add(m.name, icon, m.qualifiedName)
					else if m inherits AbstractMethod
						members.add(m.name, icon, m.resultType.name)
					else if m inherits BoxEvent
						members.add(m.name, icon, m.resultType.name)
					else if m inherits Property
						members.add(m.name, icon, m.resultType.name)
					else if m inherits BoxVar
						members.add(m.name, icon, m.type.name)
					else if m inherits BoxConst
						members.add(m.name, icon, m.type.name)
					else
						members.add(m.name, icon, m.getType.name)
		catch
			print "Failed to add [m.toString] to completion data list via .allMembers"

		return members
		
		
	def _getMethodVarCompletionData(m as AbstractMethod) as ICompletionDataList
		"""
		Given a method node, return the local variables and parameters associated with it.
		"""
		test
			ext = CobraCompletionTextEditorExtension()
			ast = .createTestData
			ns = ast.topNameSpace.memberForName("TopLevelNameSpace") to NameSpace
			ns = ns.memberForName("SecondLevelNameSpace") to NameSpace
			ns = ns.memberForName("ThirdLevelNameSpace") to NameSpace
			program = ns.memberForName("Program") to Class
			
			mainMethod = program.memberForName("main") to AbstractMethod
			completionData = ext._getMethodVarCompletionData(mainMethod)
			assert completionData.count == 6
			
			first = ns.memberForName("First") to Class
			m1 = first.memberForName("methodNoVars") to AbstractMethod
			completionData = ext._getMethodVarCompletionData(m1)
			assert completionData.count == 0
			
			m2 = first.memberForName("methodWithoutParams") to AbstractMethod
			completionData = ext._getMethodVarCompletionData(m2)
			assert completionData.count == 5
			
			m3 = first.memberForName("methodWithParams") to AbstractMethod
			completionData = ext._getMethodVarCompletionData(m3)
			assert completionData.count == 7
			
			m4 = first.memberForName("publicProperty") to Property
			completionData = ext._getMethodVarCompletionData(m4.getPart to !)
			assert completionData.count == 0
			completionData = ext._getMethodVarCompletionData(m4.setPart to !)
			assert completionData.count == 1
			
			second = ns.memberForName("Second") to Class
			third = second.memberForName("Third") to Class
			init1 = third.memberForName("cue.init") to AbstractMethod
			completionData = ext._getMethodVarCompletionData(init1)
			assert completionData.count == 1
			fourth = second.memberForName("Fourth") to Class
			init2 = fourth.memberForName("cue.init") to AbstractMethod
			completionData = ext._getMethodVarCompletionData(init2)
			assert completionData.count == 2
		body
			vars = CompletionDataList()
			
			for v in m.locals
				vars.add(v.name, _iconLocalVar, v.type.name)
			
			for p in m.params
				vars.add(p.name, _iconLocalVar, p.type.name)
			
			return vars
		
		
	shared
		def createTestData as CobraModule
			"""
			This function is only for supporting test methods.
			"""
			refs = List<of String>()
			cm = MonoDevelop.CobraBinding.CompilerManager.instance
			testData = MonoDevelop.CobraBinding.CompilerManager.readTestData("no_errors")

			for filePath, code in testData
				if filePath.endsWith("ForCompletionTesting.cobra")
					sourceMap = Dictionary<of String, String>()
					sourceMap[filePath] = code
					results = cm.parseAndBind(sourceMap, refs, filePath)
			for r in results
				if r inherits CobraModule
					return r
			throw FallThroughException()
