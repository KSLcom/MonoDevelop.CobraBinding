use Cobra.Compiler

use MonoDevelop.CobraBinding.TypeSystem

use MonoDevelop.Core
use MonoDevelop.Projects
use MonoDevelop.Ide.Gui.Content
use MonoDevelop.Ide.CodeCompletion
use MonoDevelop.Ide.TypeSystem

use ICSharpCode.NRefactory.Completion
use ICSharpCode.NRefactory.TypeSystem


namespace MonoDevelop.CobraBinding.Completion

class CobraCompletionTextEditorExtension inherits CompletionTextEditorExtension

	shared
		/#
		These are the previous maps generated by the TypeSystem.Visitor.
		They're used when the current document has parser errors.
		The containing dictionaries are keyed by the document filename.
		#/
		var __prevTypeMap = Dictionary<of String, Dictionary<of ISyntaxNode, Type>>()
		var __prevRegionMap = Dictionary<of String, Dictionary<of ISyntaxNode, DomRegion>>()

		# the various icons that show up next to completion entries
		var iconKeyword = IconId("md-keyword")
		var iconClass = IconId("md-class")
		var iconField = IconId("md-field")
		var iconLiteral = IconId("md-literal")
		var iconMethod = IconId("md-method")
		var iconDelegate = IconId("md-delegate")
		var iconStruct = IconId("md-struct")
		var iconEvent = IconId("md-event")
		var iconProperty = IconId("md-property")
		var iconInterface = IconId("md-interface")
		var iconEnum = IconId("md-enum")
		var iconNamespace = IconId("md-name-space")
		
		var keywordsTopLevel = @[
			"use",
			"namespace",
			"class",
			"interface",
			"struct",
			"mixin",
			"enum",
			"sig",
			"extend",
			"adds",
			"inherits",
			"implements",
			"has",
			"is",
		]
		
		var keywordsFollowingIs = @[
			"public",
			"protected",
			"private",
			"internal",
			"partial",
			"extern",
			"abstract",
			"override",
		]
		
		var keywordsInBox = @[
			"is",
			"def",
			"var",
			"test",
			"invariant",
			"cue init",
			"var",
			"as",
			"def",
			"pro",
			"get",
			"set",
			
			"class",
			"interface",
			"struct",
			"mixin",
			"enum",
			"sig",
		]
		
		var keywordsInMethod = @[
			"require",
			"ensure",
			"test",
			"body",
			
			"print",
			"lock",
			"using",
			"try",
			"catch",
			"finally",
			"throw",
			"assert",
			"trace",
			"if",
			"and",
			"or",
			"not",
			"in",
			"else",
			"branch",
			"on",
			"for",
			"while",
			"post",
			"return",
		]
		
		var keywordsCobraTypes = @[
			"bool",
			"char",
			"int",
			"uint",
			"float",
			"decimal",
			"number",
			"dynamic"
		]
		
		var charsToIgnore = @[
			c',',
			c')',
			c'[',
			c']',
			c'"',
			c"'",
		]
		#' TODO: handle the case above in CobraSyntaMode.xml
		
	def handleCodeCompletion(context as CodeCompletionContext?, completionChar as char,
							triggerWordLength as inout int) as ICompletionDataList? is override
		"""
		This method is called indirectly by .keyPress or when the user hits Ctrl+Space.
		"""
		
		if completionChar in .charsToIgnore
			return nil
		
		if completionChar == c'('
			#TODO handle parameter completion
			return nil
		
		/#
		.document is a MonoDevelop.Ide.Gui.Document
		.document.editor.document is a Mono.TextEditor.Document
		.document.parsedDocument is a MonoDevelop.CobraBinding.TypeSystem.ParsedCobraDocument
		#/
		if context == nil or .document == nil or .document.parsedDocument == nil
			# not enough information to be able to provide completion results
			return nil
			
		line = context.triggerLine
		col = context.triggerLineOffset
		
		textDoc = .document.editor.document
		lineText = textDoc.getLineText(line)
		if String.isNullOrEmpty(lineText), lineText = ""
		
		parsedDoc = .document.parsedDocument to ParsedCobraDocument
		
		# do not provide completion results inside comments
		commentRegions = List<of DomRegion>()
		for fold in parsedDoc.foldings
			if fold.type == FoldType.Comment
				commentRegions.add(fold.region)
		if .getContainingRegions(line, col, commentRegions).count > 0
			return nil
		
		# get code regions from last valid parse tree
		regionMap as Dictionary<of ISyntaxNode, DomRegion>? = nil
		if parsedDoc.regionMap <> nil
			regionMap = parsedDoc.regionMap
			__prevRegionMap[parsedDoc.fileName] = regionMap to !
		else if __prevRegionMap.containsKey(parsedDoc.fileName)
			regionMap = __prevRegionMap[parsedDoc.fileName]
		
		if regionMap == nil
			# not enough information to provide completion
			return nil
		
		# extend code regions to include blank lines and generate a reverse map
		codeRegions = List<of DomRegion>()
		nodeMap = Dictionary<of DomRegion, ISyntaxNode>()
		for node, region in regionMap to !
			extendedRegion = _extendRegion(region)
			codeRegions.add(extendedRegion)
			nodeMap[extendedRegion] = node
			
		for extendedRegion, node in nodeMap
			regionMap[node] = extendedRegion
		
		__prevRegionMap[parsedDoc.fileName] = regionMap to !
		
		containingRegions = .getContainingRegions(line, col, codeRegions)
		completionData = CompletionDataList()
		
		if completionChar == c'.'
			# return fields and methods in the context of the current class
			for region in containingRegions
				node = nodeMap[region]
				if node inherits Class
					completionData.addRange(_getClassMemberCompletionData(node))
			return completionData
			
		else if completionChar <> c' '
			# do this so that the letter just typed is considered part of the word to complete 
			triggerWordLength += 1
			col -= 1
			
		if col < 0
			# this can happen on manual triggering of code completion via Ctrl+Space from the start of a blank line
			col = 0
		
		# return unique completion data entries
		dataSet = HashSet<of String>()
		uniqueData = List<of ICompletionData>()
		preceedingText = lineText.substring(0, .document.editor.caret.column - 1)
				
		for region in containingRegions
			for d in _getCompletionData(region, preceedingText, "TODO", nodeMap)
				if dataSet.add(d.toString)
					uniqueData.add(d)
		
		completionData.addRange(uniqueData)
		
		if completionData.count <> 0
			return completionData
		else
			return nil
		

	def handleParameterCompletion(context as CodeCompletionContext?, completionChar as char) _
		as IParameterDataProvider? is override

		return nil

	def getContainingRegions(line as int, col as int, regions as DomRegion*) as List<of DomRegion>
		"""
		Returns a list of document regions from the given region stream that contain the 
		given document location.
		"""
		ensure # we'll never return more regions than what was given
			result.count <= List<of DomRegion>(regions).count
		test
			rs = List<of DomRegion>()
			rs.add(DomRegion(1, 1, 10, 120))
			rs.add(DomRegion(1, 1, 5, 120))
			rs.add(DomRegion(6, 1, 10, 120))
			rs.add(DomRegion(11, 1, 15, 120))
			rs.add(DomRegion(12,1, 14, 120))

			complExt = CobraCompletionTextEditorExtension()
			assert complExt.getContainingRegions(1, 1, rs).count == 2
			assert complExt.getContainingRegions(2, 1, rs).count == 2
			assert complExt.getContainingRegions(5, 80, rs).count == 2
			assert complExt.getContainingRegions(6, 10, rs).count == 2
			assert complExt.getContainingRegions(11, 1, rs).count == 1
			assert complExt.getContainingRegions(13, 1, rs).count == 2
			assert complExt.getContainingRegions(15, 20, rs).count == 1
			assert complExt.getContainingRegions(16, 1, rs).count == 0
		body
			containingRegions = List<of DomRegion>()
			for r in regions
				if r.isInside(line, col)
					containingRegions.add(r)
			return containingRegions
			
			
	def _extendRegion(region as DomRegion) as DomRegion
		"""
		Returns a copy of the given region but extends the last line
		to include all blank lines that immediately follow it.
		
		The ending point will be the 0th column of the first non-blank
		line.
		"""
		require
			.document.editor.document <> nil
			region.beginLine > 0
		ensure
			result.beginLine == region.beginLine
			result.endLine >= region.endLine
		body
			textDoc = .document.editor.document
			fromLine = region.endLine + 1
			untilLine = textDoc.lineCount + 1
			
			for line in fromLine:untilLine
				text = textDoc.getLineText(line)
				if text <> nil and text.trim.length > 0
					break
			
			extendedRegion = DomRegion(region.fileName, _
			region.beginLine, region.beginColumn, _
			line, 0)
			
			return extendedRegion

	def _getIndentLevel(line as String) as int
		"""
		Returns the number of indents for the given line.
		"""
		# Crap!  This function already exists in Parser.  Shouldn't be repeated here.
		return line.length - line.trimStart.length

	def _getTopLevelCompletionData(preceedingText as String, currText as String) as ICompletionDataList
		"""
		Returns completion data when we are in the context of a namespace and can
		declare classes, interfaces, etc.
		
		TODO: Use RegEx's instead of crossing our fingers and using string literals
		"""
		trace preceedingText
		
		dataList = CompletionDataList()
		if preceedingText.endsWith("use ")
			# provide namespaces from explicit references
			dataList.addRange(_getNamespacesFromProjectRefs)
			
		else if preceedingText.endsWith(" is ")
			for kw in .keywordsFollowingIs
				dataList.add(kw, .iconKeyword)
				
		else if preceedingText.endsWith(" as ")
			for kw in .keywordsCobraTypes
				dataList.add(kw, .iconKeyword)
			#TODO: return all types from explicit and implicit references
		
		else if preceedingText.endsWith(" inherits ")
			#TODO: return class names
			pass
			
		else if preceedingText.endsWith(" implements ")
			#TODO: return interface names
			pass
			
		else if preceedingText.endsWith(" adds ")
			#TODO: return mixin names
			pass
			
		else if preceedingText.endsWith(" has ")
			#TODO: return attribute names
			pass
			
		else
			#TODO finer context
			for kw in .keywordsTopLevel
				dataList.add(kw, .iconKeyword)
		
		return dataList

	def _getCompletionData(region as DomRegion, preceedingText as String, currText as String,
							nodeMap as Dictionary<of DomRegion, ISyntaxNode>) as ICompletionDataList
		"""
		Returns completion data in the context of the given DomRegion.
		"""
		require
			.document.editor <> nil
			.document.editor.document <> nil
		body
			dataList = CompletionDataList()
			dataList.addRange(_getTopLevelCompletionData(preceedingText, currText))
			
			textDoc = .document.editor.document
			firstRegionLine = textDoc.getLineText(region.beginLine).trimStart
			
			if firstRegionLine.startsWith("namespace ")
				# being inside a namespace means we have access to all the classes inside of it
				dataList.addRange(_getNamespaceCompletionData(nodeMap[region] to NameSpace))
				
			else if firstRegionLine.startsWith("class ")
				# being inside a class gives us access to all its fields and methods
				for kw in .keywordsInBox
					dataList.add(kw, .iconKeyword)
				
				dataList.addRange(_getClassMemberCompletionData(nodeMap[region] to Class))
				
			else if firstRegionLine.startsWith("def ") or firstRegionLine.startsWith("get ") or firstRegionLine.startsWith("set ")
				# being inside a method gives us access to all its local variables and more Cobra keywords
				for kw in .keywordsInMethod
					dataList.add(kw, .iconKeyword)
				
				if firstRegionLine.startsWith("def ")
					dataList.addRange(_getMethodVarCompletionData(nodeMap[region] to AbstractMethod))
			
			return dataList

	def _getNamespacesFromProjectRefs as ICompletionDataList
		"""
		Returns the namespaces of the types in the current project references
		"""
		#TODO do it right with only one namespace level at as time
		nsList = List<of String>()
		
		proj = .document.project to DotNetProject
		for r in proj.references
			for asmFileName in r.getReferencedFileNames(DefaultConfigurationSelector())
				try
					asm = System.Reflection.Assembly.loadFile(asmFileName)
					if asm <> nil
						for t in asm.getTypes
							if t.namespace <> nil and t.namespace not in nsList
								nsList.add(t.namespace)
				catch ex as Exception
					# failed to load assembly, just ignore it for now
					trace ex.message
		
		dataList = CompletionDataList()
		
		for ns in nsList
			dataList.add(ns, .iconNamespace)
		
		return dataList
		
	def _getNamespaceCompletionData(n as NameSpace) as ICompletionDataList
		"""
		Given a namespace node, return the namespaces and types it provides.
		"""
		
		decls = CompletionDataList()
		
		for d in n.declsInOrder
			if d inherits Class
				decls.add(d.name, .iconClass)
			else if d inherits MethodSig
				decls.add(d.name, .iconDelegate)
			else if d inherits Struct
				decls.add(d.name, .iconStruct)
			else if d inherits Interface
				decls.add(d.name, .iconInterface)
			else if d inherits NameSpace
				decls.add(d.name, .iconNamespace)
			else if d inherits EnumDecl
				decls.add(d.name, .iconEnum)
		
		return decls
		
	def _getClassMemberCompletionData(c as Class) as ICompletionDataList
		"""
		Given a class node, return the members associated with it.
		"""
		
		decls = CompletionDataList()
		
		for d in c.declsInOrder
			if d inherits AbstractMethod
				decls.add(d.name, .iconMethod)
			else
				decls.add(d.name, .iconField)
		
		return decls
		
	def _getMethodVarCompletionData(m as AbstractMethod) as ICompletionDataList
		"""
		Given a method node, return the local variables and parameters associated with it.
		"""
		
		vars = CompletionDataList()
		
		for v in m.locals
			vars.add(v.name, .iconField)
		
		for s in m.statements
			if s inherits AssignExpr
				if s.left inherits IdentifierExpr
					idExpr = s.left to IdentifierExpr
					vars.add(idExpr.name, .iconField)
			else if s inherits ForStmt
				vars.add(s.varExpr.name, .iconField)
		
		for p in m.params
			vars.add(p.name, .iconField)
		
		return vars
