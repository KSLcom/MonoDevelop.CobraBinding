use System.Text.RegularExpressions

use Cobra.Compiler

use MonoDevelop.CobraBinding.TypeSystem

use MonoDevelop.Core
use MonoDevelop.Projects
use MonoDevelop.Ide.Gui.Content
use MonoDevelop.Ide.CodeCompletion
use MonoDevelop.Ide.TypeSystem

use ICSharpCode.NRefactory.Completion
use ICSharpCode.NRefactory.TypeSystem


namespace MonoDevelop.CobraBinding.Completion

class CobraCompletionTextEditorExtension inherits CompletionTextEditorExtension

	shared
		/#
		This is the previous map generated by the TypeSystem.Visitor.
		It's used when the current document has parser errors.
		The containing dictionary is keyed by the document filename.
		#/
		var __prevRegionMap = Dictionary<of String, _
			Dictionary<of ISyntaxNode, DomRegion>>()

		# likewise with the previous symbol table
		var __prevSymbolTable = Dictionary<of String, _
			Dictionary<of DomRegion, Dictionary<of String, INamedNode>?>?>()

		# the various icons that show up next to completion entries
		var iconKeyword = IconId("md-keyword")
		var iconClass = IconId("md-class")
		var iconField = IconId("md-field")
		var iconLiteral = IconId("md-literal")
		var iconMethod = IconId("md-method")
		var iconDelegate = IconId("md-delegate")
		var iconStruct = IconId("md-struct")
		var iconEvent = IconId("md-event")
		var iconProperty = IconId("md-property")
		var iconInterface = IconId("md-interface")
		var iconEnum = IconId("md-enum")
		var iconNamespace = IconId("md-name-space")
		
		var keywordsTopLevel = @[
			"use",
			"namespace",
			"class",
			"interface",
			"struct",
			"mixin",
			"enum",
			"sig",
			"extend",
			"adds",
			"inherits",
			"implements",
			"has",
			"is",
		]
		
		var keywordsFollowingIs = @[
			"public",
			"protected",
			"private",
			"internal",
			"partial",
			"extern",
			"abstract",
			"override",
		]
		
		var keywordsInBox = @[
			"is",
			"def",
			"var",
			"test",
			"invariant",
			"cue init",
			"var",
			"as",
			"def",
			"pro",
			"get",
			"set",
			
			"class",
			"interface",
			"struct",
			"mixin",
			"enum",
			"sig",
		]
		
		var keywordsInMethod = @[
			"require",
			"ensure",
			"test",
			"body",
			
			"print",
			"lock",
			"using",
			"try",
			"catch",
			"finally",
			"throw",
			"assert",
			"trace",
			"if",
			"and",
			"or",
			"not",
			"in",
			"else",
			"branch",
			"on",
			"for",
			"while",
			"post",
			"return",
		]
		
		var keywordsCobraTypes = @[
			"bool",
			"char",
			"int",
			"uint",
			"float",
			"decimal",
			"number",
			"dynamic"
		]
		
		var charsToIgnore = @[
			c',',
			c')',
			c'[',
			c']',
			c'"',
			c"'",
		]
		#' TODO: handle the case above in CobraSyntaMode.xml
		
	def handleCodeCompletion(context as CodeCompletionContext?, completionChar as char,
							triggerWordLength as inout int) as ICompletionDataList? is override
		"""
		This method is called indirectly by .keyPress or when the user hits Ctrl+Space.
		"""

		if completionChar in .charsToIgnore
			return nil

		if completionChar == c'('
			#TODO handle parameter completion
			return nil

		/#
		.document is a MonoDevelop.Ide.Gui.Document
		.document.editor.document is a Mono.TextEditor.Document
		.document.parsedDocument is a MonoDevelop.CobraBinding.TypeSystem.ParsedCobraDocument
		#/
		if context == nil or .document == nil or .document.parsedDocument == nil
			# not enough information to be able to provide completion results
			return nil

		line = context.triggerLine
		col = context.triggerLineOffset

		textDoc = .document.editor.document
		lineText = textDoc.getLineText(line)
		if String.isNullOrEmpty(lineText), lineText = ""

		parsedDoc = .document.parsedDocument to ParsedCobraDocument

		if _isInsideComment(line, col, lineText to !)
			return nil

		# get code regions from last valid parse tree
		regionMap as Dictionary<of ISyntaxNode, DomRegion>? = nil
		if parsedDoc.regionMap <> nil
			regionMap = parsedDoc.regionMap
			__prevRegionMap[parsedDoc.fileName] = regionMap to !
		else if __prevRegionMap.containsKey(parsedDoc.fileName)
			regionMap = __prevRegionMap[parsedDoc.fileName]

		if regionMap == nil
			# not enough information to provide completion
			return nil

		# get symbol table
		symbolTable as Dictionary<of DomRegion, Dictionary<of String, INamedNode>?>? = nil
		if parsedDoc.symbolTable <> nil
			symbolTable = parsedDoc.symbolTable
			__prevSymbolTable[parsedDoc.fileName] = symbolTable to !
		else if __prevSymbolTable.containsKey(parsedDoc.fileName)
			symbolTable = __prevSymbolTable[parsedDoc.fileName]

		if symbolTable == nil
			# not enough information to provide completion
			return nil

		# extend code regions to include blank lines and generate a reverse map
		codeRegions = List<of DomRegion>()
		nodeMap = Dictionary<of DomRegion, ISyntaxNode>()
		for node, region in regionMap to !
			extendedRegion = _extendRegion(region)
			codeRegions.add(extendedRegion)
			nodeMap[extendedRegion] = node
			idMap as Dictionary<of String, INamedNode>? = nil
			if symbolTable.tryGetValue(region, out idMap)
				symbolTable.remove(region)
				symbolTable[extendedRegion] = idMap

		for extendedRegion, node in nodeMap
			regionMap[node] = extendedRegion

		# DEBUGGING
		/#
		for node, region in regionMap to !
			trace node.getType.toString
			trace region.toString
		#/
		__prevRegionMap[parsedDoc.fileName] = regionMap to !

		if completionChar <> c' '
			# do this so that the letter just typed is considered part of the word to complete
			while col > 0 and lineText[col - 1] not in @[c'\t', c' ']
				triggerWordLength += 1
				col -= 1

		if col < 0
			# this can happen on manual triggering of code completion via Ctrl+Space from the start of a blank line
			col = 0

		containingRegions = .getContainingRegions(line, col, codeRegions)
		completionData = CompletionDataList()
		preceedingText = lineText.substring(0, .document.editor.caret.column - 1)

		if completionChar == c'.'
			# member completion

			# don't include the dot or anything before it in the trigger word length
			triggerWordLength = 0

			ids = _getIdsFromText(preceedingText)

			/#
			for id in ids
				trace id
			#/

			if ids.count == 0
				# return fields and methods in the context of the current class
				for region in containingRegions
					node = nodeMap[region]
					if node inherits Class
						completionData.addRange(_getBoxMemberCompletionData(node))
				return completionData
			else
				# return fields and methods for the corresponding node
				try
					node = _getNodeFromIds(ids, containingRegions, symbolTable)
					#trace node.toString

					if node inherits AbstractLocalVar
						if node.type inherits Box
							completionData.addRange(_getBoxMemberCompletionData(node.type to Box))
					else if node inherits NameSpace
						completionData.addRange(_getNamespaceCompletionData(node))
					else if node implements Cobra.Compiler.IMember
						if node.resultType inherits Box
							completionData.addRange(_getBoxMemberCompletionData(node.resultType to Box))
					
					print "should be displaying members for [node]"

					return completionData
				catch ArgumentException
					# not a valid identifier
					return nil

		# return unique completion data entries
		dataSet = HashSet<of String>()
		uniqueData = List<of ICompletionData>()

		for region in containingRegions
			for d in _getCompletionData(region, preceedingText, "TODO", nodeMap)
				if dataSet.add(d.toString)
					uniqueData.add(d)

		completionData.addRange(uniqueData)

		if completionData.count <> 0
			return completionData
		else
			return nil


	def handleParameterCompletion(context as CodeCompletionContext?, completionChar as char) _
		as IParameterDataProvider? is override

		return nil
		

	def _isInsideComment(line as int, col as int, lineText as String) as bool
		"""
		Returns true if the cursor is inside a comment region.
		"""
		if line < 1, line = 1
		if col < 0, col = 0
		
		if lineText.trimStart.startsWith("#")
			#TODO: Detect cases when inside a string or inside trailing comments
			return true
		
		parsedDoc = .document.parsedDocument to ParsedCobraDocument
		
		for fold in parsedDoc.foldings
			if fold.type == FoldType.Comment and fold.region.isInside(line, col)
				return true
				
		return false
		

	def getContainingRegions(line as int, col as int, regions as DomRegion*) as List<of DomRegion>
		"""
		Returns a list of document regions from the given region stream that contain the 
		given document location.
		"""
		ensure # we'll never return more regions than what was given
			result.count <= List<of DomRegion>(regions).count
		test
			rs = List<of DomRegion>()
			rs.add(DomRegion(1, 1, 10, 120))
			rs.add(DomRegion(1, 1, 5, 120))
			rs.add(DomRegion(6, 1, 10, 120))
			rs.add(DomRegion(11, 1, 15, 120))
			rs.add(DomRegion(12,1, 14, 120))

			complExt = CobraCompletionTextEditorExtension()
			assert complExt.getContainingRegions(1, 1, rs).count == 2
			assert complExt.getContainingRegions(2, 1, rs).count == 2
			assert complExt.getContainingRegions(5, 80, rs).count == 2
			assert complExt.getContainingRegions(6, 10, rs).count == 2
			assert complExt.getContainingRegions(11, 1, rs).count == 1
			assert complExt.getContainingRegions(13, 1, rs).count == 2
			assert complExt.getContainingRegions(15, 20, rs).count == 1
			assert complExt.getContainingRegions(16, 1, rs).count == 0
		body
			containingRegions = List<of DomRegion>()
			for r in regions
				if r.isInside(line, col)
					containingRegions.add(r)

			return containingRegions
			
			
	def _extendRegion(region as DomRegion) as DomRegion
		"""
		Returns a copy of the given region but extends the last line
		to include all blank lines that immediately follow it.
		
		The ending point will be the 0th column of the first non-blank
		line.
		"""
		require
			.document.editor.document <> nil
			region.beginLine > 0
		ensure
			result.beginLine == region.beginLine
			result.endLine >= region.endLine
		body
			textDoc = .document.editor.document
			fromLine = region.endLine + 1
			untilLine = textDoc.lineCount + 1
			
			for line in fromLine:untilLine
				text = textDoc.getLineText(line)
				if text <> nil and text.trim.length > 0
					break
			
			extendedRegion = DomRegion(region.fileName, _
			region.beginLine, region.beginColumn, _
			line, 0)
			
			return extendedRegion

	def _getIndentLevel(line as String) as int
		"""
		Returns the number of indents for the given line.
		"""
		# Crap!  This function already exists in Parser.  Shouldn't be repeated here.
		return line.length - line.trimStart.length


	shared
		var rexIdentifier = Regex( _
			r'[a-zA-z0-9]*', _
			RegexOptions.Compiled _
		)

	def _getIdsFromText(text as String) as List<of String>
		"""
		Given a line of text, returns a list of trailing identifiers.

		For example, given "foo = SomeSharedClass.someProp.", then this
		method would return ['SomeSharedClass', 'someProp'].
		"""
		test
			sampleText = "foo = SomeSharedClass.someProp."
			completionExtension = CobraCompletionTextEditorExtension()
			ids = completionExtension._getIdsFromText(sampleText)
			assert ids.count == 2
			assert ids[0] == "SomeSharedClass"
			assert ids[1] == "someProp"
		body
			ids = List<of String>()
			text = text.trim

			# split the text by whitespace
			pieces = text.split
			lastPiece = pieces[pieces.length - 1]

			match = CobraCompletionTextEditorExtension.rexIdentifier.match(lastPiece)
			while match.success
				if match.value.length > 0
					ids.add(match.value)
				match = match.nextMatch to !

			return ids

	def _getNodeFromIds(ids as List<of String>,
						containingRegions as List<of DomRegion>,
						symbolTable as Dictionary<of DomRegion, Dictionary<of String, INamedNode>>) as ISyntaxNode
		"""
		Given a list of identifiers, returns the syntax node in the AST
		corresponding to the last valid idenfiier.

		Throws an ArgumentException if no node is found.
		"""
		require
			ids.count > 0
			containingRegions.count > 0

		test singleIdentifier
			# setup
			ids = ['Object']
			regions = [DomRegion(1,1)]
			bogusNode = Class('Object', List<of Cobra.Compiler.IType>())
			symbolTable = Dictionary<of DomRegion, Dictionary<of String, INamedNode>>()
			symbolTable[regions[0]] = Dictionary<of String, INamedNode>()
			symbolTable[regions[0]]['Object'] = bogusNode

			# the test
			completionExtension = CobraCompletionTextEditorExtension()
			assert completionExtension._getNodeFromIds(ids, regions, symbolTable) is bogusNode
			
		test multipleIdentifiers
			#TODO
			# setup
			# the test
			pass

		body
			#TODO: still feels ugly...
			correspondingNode as ISyntaxNode? = nil
			idMap as Dictionary<of String, INamedNode>? = nil

			for region in containingRegions
				
				found = false

				if symbolTable.tryGetValue(region, out idMap)
				
					for id, node in idMap
					
						if id == ids[0]
							correspondingNode = node to ISyntaxNode
							found = true
							break
							
					if found, break
				if found, break
			
			if found
				# we found a node with this name, limit the rest of our search to this node
				try
					print correspondingNode
					return _getNodeFromIds(ids[1:ids.count], correspondingNode)
				catch
					return correspondingNode to !
					
			throw ArgumentException()
			
	def _getNodeFromIds(ids as List<of String>, parent as ISyntaxNode) as ISyntaxNode
		"""
		Given a list of identifiers, returns the syntax node in the AST
		corresponding to the last valid idenfiier.

		Throws an ArgumentException if no node is found.
		"""
		if ids.count == 0
			return parent
		
		if parent implements INamedNode
		
			if parent.typeForReceiver implements IContainer
		
				t = parent.typeForReceiver
		
				if t inherits NameSpace
					for useDirective in t.useDirectives
						if useDirective.boundNameSpace <> nil
							nsMember = useDirective.boundNameSpace.memberForName(ids[0])
							if nsMember <> nil
								try
									return _getNodeFromIds(ids[1:ids.count], nsMember to ISyntaxNode)
								catch
									return parent to ISyntaxNode
		
				m = t.memberForName(ids[0])
				if m <> nil
					try
						return _getNodeFromIds(ids[1:ids.count], m to ISyntaxNode)
					catch
						return parent to ISyntaxNode
			else
				print "[parent.typeForIdentifier.name] does not implement IContainer"
		
		throw ArgumentException()
				
			
	def _getTopLevelCompletionData(preceedingText as String, currText as String) as ICompletionDataList
		"""
		Returns completion data when we are in the context of a namespace and can
		declare classes, interfaces, etc.
		
		TODO: Use RegEx's instead of crossing our fingers and using string literals
		"""
		
		dataList = CompletionDataList()
		if preceedingText.endsWith("use ")
			# provide namespaces from explicit references
			dataList.addRange(_getNamespacesFromProjectRefs)
			
		else if preceedingText.endsWith(" is ")
			for kw in .keywordsFollowingIs
				dataList.add(kw, .iconKeyword)
				
		else if preceedingText.endsWith(" as ") or preceedingText.endsWith(" = ")
			for kw in .keywordsCobraTypes
				dataList.add(kw, .iconKeyword)
			
			# return all imported decls
			dataList.addRange(_getAvailableDecls)
		
		else if preceedingText.endsWith(" inherits ")
			#TODO: return class names
			pass
			
		else if preceedingText.endsWith(" implements ")
			#TODO: return interface names
			pass
			
		else if preceedingText.endsWith(" adds ")
			#TODO: return mixin names
			pass
			
		else if preceedingText.endsWith(" has ")
			#TODO: return attribute names
			pass
			
		else
			#TODO finer context
			for kw in .keywordsTopLevel
				dataList.add(kw, .iconKeyword)
		
		return dataList

	def _getCompletionData(region as DomRegion, preceedingText as String, currText as String,
							nodeMap as Dictionary<of DomRegion, ISyntaxNode>) as ICompletionDataList
		"""
		Returns completion data in the context of the given DomRegion.
		"""
		require
			.document.editor <> nil
			.document.editor.document <> nil
		body
			dataList = CompletionDataList()
			dataList.addRange(_getTopLevelCompletionData(preceedingText, currText))
			
			textDoc = .document.editor.document
			firstRegionLine = textDoc.getLineText(region.beginLine).trimStart
			
			if firstRegionLine.startsWith("namespace ")
				# being inside a namespace means we have access to all the classes inside of it
				dataList.addRange(_getNamespaceCompletionData(nodeMap[region] to NameSpace))
				
			else if firstRegionLine.startsWith("class ") and nodeMap[region] inherits Class
				/#
				Implicit class initializers would also fall into this block if we didn't check
				to make sure that the node inherits from 'Class.'
				#/
			
				# being inside a class gives us access to all its fields and methods
				for kw in .keywordsInBox
					dataList.add(kw, .iconKeyword)
				
				dataList.addRange(_getBoxMemberCompletionData(nodeMap[region] to Class))
				
			else if firstRegionLine.startsWith("def ") or firstRegionLine.startsWith("get ") or firstRegionLine.startsWith("set ")
				# being inside a method gives us access to all its local variables and more Cobra keywords
				for kw in .keywordsInMethod
					dataList.add(kw, .iconKeyword)
				
				if firstRegionLine.startsWith("def ")
					dataList.addRange(_getMethodVarCompletionData(nodeMap[region] to AbstractMethod))
			
			return dataList

	def _getNamespacesFromProjectRefs as ICompletionDataList
		"""
		Returns the namespaces of the types in the current project references
		"""
		#TODO do it right with only one namespace level at as time
		nsList = List<of String>()
		
		proj = .document.project to DotNetProject
		for r in proj.references
			for asmFileName in r.getReferencedFileNames(DefaultConfigurationSelector())
				try
					asm = System.Reflection.Assembly.loadFile(asmFileName)
					if asm <> nil
						for t in asm.getTypes
							if t.namespace <> nil and t.namespace not in nsList
								nsList.add(t.namespace)
				catch ex as Exception
					# failed to load assembly, just ignore it for now
					print ex.message
		
		dataList = CompletionDataList()
		
		for ns in nsList
			dataList.add(ns, .iconNamespace)
		
		return dataList
		
	def _getAvailableDecls as ICompletionDataList
		"""
		Returns all declarations visible in the current context.
		"""
		require
			.document
			.document.parsedDocument
		body
			dataList = CompletionDataList()
			ast as CobraModule? = .document.parsedDocument.getAst<of CobraModule>
			if ast == nil
				return dataList
			
			dataList.addRange(_getNamespaceCompletionData(ast.topNameSpace))
			
			for useStmt in ast.topNameSpace.useDirectives
				if useStmt.boundNameSpace <> nil
					ns = useStmt.boundNameSpace to !
					dataList.addRange(_getNamespaceCompletionData(ns))
			
			return dataList
		
		
	def _getNamespaceCompletionData(n as NameSpace) as ICompletionDataList
		"""
		Given a namespace node, return the namespaces and types it provides.
		"""
		decls = CompletionDataList()
		
		if n.name.startsWith('(')
			# an unnamed top-level namespace for a module
			nsNamePrefix = ""
		else
			nsNamePrefix = n.name + "."
		
		for d in n.declsInOrder
			if d inherits MethodSig
				decls.add(d.name, .iconDelegate, d.qualifiedName)
			else if d inherits Class
				decls.add(d.name, .iconClass, d.qualifiedName)
			else if d inherits Struct
				decls.add(d.name, .iconStruct, d.qualifiedName)
			else if d inherits Interface
				decls.add(d.name, .iconInterface, d.qualifiedName)
			else if d inherits NameSpace
				decls.add(d.name, .iconNamespace, nsNamePrefix + d.name)
			else if d inherits EnumDecl
				decls.add(d.name, .iconEnum, nsNamePrefix + d.name)
		
		return decls
		
		
	def _getBoxMemberCompletionData(b as Box) as ICompletionDataList
		"""
		Given a box node, return the unique members associated with it.
		"""
		seen = HashSet<of String>()
		
		# pretend we've already seen 'cue.init' so it's not included in the final list
		seen.add("cue.init")
		
		members = CompletionDataList()

		#TODO: clean this up
		for m in b.declsInOrder
			if seen.add(m.name)
				try
					if m inherits MethodSig
						members.add(m.name, .iconDelegate, m.qualifiedName)
					else if m inherits AbstractMethod
						members.add(m.name, .iconMethod, m.resultType.name)
					else if m inherits BoxEvent
						members.add(m.name, .iconEvent, m.resultType.name)
					else if m inherits Property
						members.add(m.name, .iconProperty, m.resultType.name)
					else if m inherits BoxVar
						members.add(m.name, .iconField, m.type.name)
					else if m inherits BoxConst
						members.add(m.name, .iconLiteral, m.type.name)
					else
						members.add(m.name, .iconEvent, "TODO: use correct icon")
				catch
					if m inherits MethodSig
						members.add(m.name, .iconDelegate, "Failed to evaluate 'm.qualifiedName'")
					else if m inherits AbstractMethod
						members.add(m.name, .iconMethod, "Failed to evaluate 'm.resultType.name'")
					else if m inherits BoxEvent
						members.add(m.name, .iconEvent, "Failed to evaluate 'm.resultType.name'")
					else if m inherits Property
						members.add(m.name, .iconProperty, "Failed to evaluate 'm.resultType.name'")
					else if m inherits BoxVar
						members.add(m.name, .iconField, "Failed to evaluate 'm.type.name'")
					else if m inherits BoxConst
						members.add(m.name, .iconLiteral, "Failed to evaluate 'm.type.name'")
					else
						members.add(m.name, .iconEvent, "TODO: use correct icon")
		
		try
			for m in b.allMembers
				if seen.add(m.name)
					if m inherits MethodSig
						members.add(m.name, .iconDelegate, m.qualifiedName)
					else if m inherits AbstractMethod
						members.add(m.name, .iconMethod, m.resultType.name)
					else if m inherits BoxEvent
						members.add(m.name, .iconEvent, m.resultType.name)
					else if m inherits Property
						members.add(m.name, .iconProperty, m.resultType.name)
					else if m inherits BoxVar
						members.add(m.name, .iconField, m.type.name)
					else if m inherits BoxConst
						members.add(m.name, .iconLiteral, m.type.name)
					else
						members.add(m.name, .iconEvent, "TODO: use correct icon")
		catch
			print "Failed to add [m.toString] to completion data list via .allMembers"

		return members
		
		
	def _getMethodVarCompletionData(m as AbstractMethod) as ICompletionDataList
		"""
		Given a method node, return the local variables and parameters associated with it.
		"""
		vars = CompletionDataList()
		
		for v in m.locals
			vars.add(v.name, .iconField, v.type.name)
		
		for p in m.params
			vars.add(p.name, .iconField, p.type.name)
		
		return vars
