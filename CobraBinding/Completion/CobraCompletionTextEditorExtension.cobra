use System.Text.RegularExpressions

use Cobra.Compiler

use MonoDevelop.CobraBinding.TypeSystem

use MonoDevelop.Core
use MonoDevelop.Projects
use MonoDevelop.Ide.Gui.Content
use MonoDevelop.Ide.CodeCompletion
use MonoDevelop.Ide.TypeSystem

use ICSharpCode.NRefactory.Completion
use ICSharpCode.NRefactory.TypeSystem


namespace MonoDevelop.CobraBinding.Completion

class CobraCompletionTextEditorExtension inherits CompletionTextEditorExtension

	shared
		/#
		These '__prev' maps are used when the current parsed
		document has errors or the previous values have better
		information for completion (i.e. bound vs unbound types).
		
		They are all keyed by fileName.
		#/
		var __prevAstMap = Dictionary<of String, CobraModule?>()

		var __prevRegionMap = Dictionary<of String, _
			Dictionary<of ISyntaxNode, DomRegion>>()

		var __prevSymbolTable = Dictionary<of String, _
			Dictionary<of DomRegion, Dictionary<of String, INamedNode>?>>()
		
		
	get ast as CobraModule?
		"""
		Return the last valid abstract syntax tree from the parsed document (if any).
		"""
		require
			.document <> nil
			.document.parsedDocument <> nil
		body
			parsedDoc = .document.parsedDocument
			currAst = parsedDoc.getAst<of CobraModule?>
			prevAst as CobraModule? = nil
			if __prevAstMap.containsKey(parsedDoc.fileName)
				prevAst = __prevAstMap[parsedDoc.fileName]
			
			if prevAst == nil
				# save for next time
				__prevAstMap[parsedDoc.fileName] = currAst
				return currAst
				
			else if currAst <> nil
				# prefer type-bound ASTs
				if currAst.didBindImp
					# current AST is bound, save for next time
					__prevAstMap[parsedDoc.fileName] = currAst
					return currAst
				else if prevAst.didBindImp or parsedDoc.hasErrors
					# previous AST has better information
					return prevAst
				else
					# save for next time, even though it's unbound
					__prevAstMap[parsedDoc.fileName] = currAst
					return currAst
			
			return prevAst

	
	get regionMap as Dictionary<of ISyntaxNode, DomRegion>
		"""
		Return code regions from last valid AST.
		Values are keyed by the declaring syntax node.
		"""
		require
			.document <> nil
			.document.parsedDocument <> nil
			.document.parsedDocument inherits ParsedCobraDocument
		body
			parsedDoc = .document.parsedDocument to ParsedCobraDocument
			map = parsedDoc.regionMap
			
			if map <> nil
				__prevRegionMap[parsedDoc.fileName] = map
				return map
			else if __prevRegionMap.containsKey(parsedDoc.fileName)
				return __prevRegionMap[parsedDoc.fileName]
			
			return Dictionary<of ISyntaxNode, DomRegion>()
	
	
	get symbolTable as Dictionary<of DomRegion, Dictionary<of String, INamedNode>?>
		"""
		Return the symbol table from last valid AST.
		Values are nilable dictionaries mapping identifiers	to
		their corresponding nodes and are keyed by code region.
		"""
		require
			.document <> nil
			.document.parsedDocument <> nil
			.document.parsedDocument inherits ParsedCobraDocument
		body
			parsedDoc = .document.parsedDocument to ParsedCobraDocument
			currAst = parsedDoc.getAst<of CobraModule?>
			if currAst <> nil and not currAst.didBindImp _
			and __prevAstMap.containsKey(parsedDoc.fileName) _
			and __prevSymbolTable.containsKey(parsedDoc.fileName)
				# the previous symbol table probably has more information
				return __prevSymbolTable[parsedDoc.fileName]
			
			table = parsedDoc.symbolTable
			
			if table <> nil
				__prevSymbolTable[parsedDoc.fileName] = table
				return table
			else if __prevSymbolTable.containsKey(parsedDoc.fileName)
				return __prevSymbolTable[parsedDoc.fileName]
			
			return Dictionary<of DomRegion, Dictionary<of String, INamedNode>?>()
	
	shared
		var _charsToIgnore = @[
			c' ',
			c'\t',
			c',',
			c')',
			c'[',
			c']',
			c'"',
			c"'",
			c'=',
		]
		#'# TODO: handle the syntax highlighting bug above in CobraSyntaMode.xml
	
	def _canHandleCodeCompletion(context as CodeCompletionContext?, completionChar as char) as bool
		"""
		Returns true if the extension is able to provide completion results in the given
		context for the given completion character or false otherwise.
		"""
		if completionChar in _charsToIgnore
			return false
			
		# .document is a MonoDevelop.Ide.Gui.Document
		# .document.parsedDocument is a MonoDevelop.CobraBinding.TypeSystem.ParsedCobraDocument
		if context == nil _
		or .document == nil _
		or .document.parsedDocument == nil _
		or .editor == nil
			return false

		if _isInsideComment(context)
			return false
			
		if _isInsideString(context)
			return false
			
		parsedDoc = .document.parsedDocument to ParsedCobraDocument
		if parsedDoc.regionMap == nil and not __prevRegionMap.containsKey(parsedDoc.fileName)
			return false
			
		if parsedDoc.symbolTable == nil and not __prevSymbolTable.containsKey(parsedDoc.fileName)
			return false
	
		return true
		
	
	def keyPress(key as Gdk.Key, keyChar as char, modifier as Gdk.ModifierType) as bool is override
		"""
		Look for Return/Enter key presses and extend regions of doc strings and comment blocks.
		"""
		if key == Gdk.Key.Return or key == Gdk.Key.KP_Enter
			if .document and .document.parsedDocument
				line = .editor.caret.line - 1
				prevLineText  = .editor.getLineText(line) ? ""
				col = prevLineText.length + 1
				for fold in .document.parsedDocument.foldings
					if fold.type == FoldType.Comment
						if fold.region.isInside(line, col)
							fold.region = _resizeNonCodeRegion(fold.region)
		
		# Returns true if the key that was pressed should be processed by this extension or not.
		return base.keyPress(key, keyChar, modifier)
		
		
	def _resizeNonCodeRegion(region as DomRegion) as DomRegion
		"""
		Extends the given DomRegion based on the text contents of the document.  Useful for
		handling Enter/Return key-presses before the regions of the .parsedDocument have been
		updated by the parser.
		"""
		require
			.editor
		body
			if .editor.getLineText(region.beginLine).contains('"""')
				# look for closing doc string tag
				tag = '"""'
			else if .editor.getLineText(region.beginLine).contains("'''")
				# look for alternate style closing doc string tag
				tag = "'''"
			else
				# assume we are resizing a comment block, might be a bad assumption...
				tag = "#/"
			
			lineNum = region.beginLine + 1
			
			while lineNum < .editor.lineCount
				lineText = .editor.getLineText(lineNum)
				if lineText.contains(tag)
					break
				else
					lineNum += 1
			
			endLocation = ICSharpCode.NRefactory.TextLocation(lineNum, Int32.maxValue)
			return DomRegion(region.fileName, region.begin, endLocation)
			
	
	def handleCodeCompletion(context as CodeCompletionContext?, completionChar as char,
							triggerWordLength as inout int) as ICompletionDataList? is override
		"""
		This method is called indirectly by .keyPress or when the user hits Ctrl+Space.
		"""

		if not _canHandleCodeCompletion(context, completionChar)
			# not enough information to provide completion results
			return nil

		if completionChar == c'('
			#TODO handle parameter completion
			return nil
		
		# get code regions and symbol table from last valid AST
		regionMap = .regionMap
		symbolTable = .symbolTable
		
		# extend code regions to include blank lines
		_extendRegions(regionMap, symbolTable)
		
		# generate a reverse map (regions to nodes)
		nodeMap = _createNodeMap(regionMap)
		node as ISyntaxNode? = nil

		line = context.triggerLine
		col = context.triggerLineOffset
		
		lineText = .editor.document.getLineText(line) ? ""

		containingRegions = .getContainingRegions(line, col, regionMap.values)
		
		completionData = CompletionDataList()
		if .editor.caret.column - 2 > 0
			preceedingText = lineText.substring(0, .editor.caret.column - 2)
		else
			preceedingText = ""
		#print "preceedingText = [preceedingText]"
		#print "completionChar = [completionChar]\n"
		
		if completionChar == c'_' _
		and (preceedingText.endsWith(' ') or preceedingText.endsWith('\t') or preceedingText.length == 0)
			# protected/private member completion in the context of the current class
			triggerWordLength += 1
			
			node = _getContainingBox(containingRegions, nodeMap)
			if node inherits Box
				return BoxMembersList(node)
		
		else if completionChar == c'.'
			# member completion

			# don't include the dot or anything before it in the trigger word length
			triggerWordLength = 0

			if preceedingText.endsWith(' ') or preceedingText.endsWith('\t') or preceedingText.length == 0
				# return fields and methods in the context of the current class
				node = _getContainingBox(containingRegions, nodeMap)
				if node inherits Box
					return BoxMembersList(node)
			else
				# return fields and methods for the corresponding node
				
				if preceedingText.endsWith(")")
					# try to backtrack to the opening parenthesis
					# TODO: handle.multiple(calls).and(more, cases).likeThis
					for pos in preceedingText.length - 1 : 0 : -1
						if preceedingText[pos] == c'(', break
					preceedingText = preceedingText.substring(0, pos)
					#print "new preceedingText = [preceedingText]\n"
				
				ids = _getIdsFromText(preceedingText)
				
				try
					node = _getNodeFromIds(ids, containingRegions, symbolTable)
					typ as Cobra.Compiler.IType? = nil
					
					if node inherits NameSpace
						completionData.addRange(NameSpaceDeclsList(node))
					
					else if node inherits AbstractLocalVar
						# this could be a method parameter or local variable
						typ = node.type
					
					else if node implements Cobra.Compiler.IMember
						# this is a box/namespace member
						typ = node.resultType
					
					if typ <> nil
						if typ inherits NilableType
							typ = typ.nonNil
						
						if typ inherits PrimitiveType
							typ = typ.box
						else if typ inherits Cobra.Compiler.ArrayType
							typ = typ.box
							
						members as ICompletionDataList? = nil
						
						if typ inherits Box
							if node inherits NamedNode
								if node.name.isCapitalized
									# probably a class so only provide shared members
									members = DataFactory.createBoxSharedMembersList(typ)
								else
									# probably a field or method
									members = DataFactory.createBoxInstanceMembersList(typ)
							else
								# a literal or something else we can probably treat as an instance...right?
								print "this is unexpected. [node] does not inherit NamedNode\n"
								members = DataFactory.createBoxInstanceMembersList(typ)
						else
							print "typ does not inherit Box. typ = [typ]\n"
							
						if members <> nil, completionData.addRange(members)
					else
						print "[node] does not inherit AbstractLocalVar and does not implement Cobra.Compiler.IMember\n"
					
					print "should be displaying members for [node]\n"
					return completionData
					
				catch ArgumentException
					# not a valid identifier
					print "couldn't resolve [ids] to a node\n"
					return nil
					
		else
			# do this so that the letter just typed is considered part of the word to complete
			while col > 0 and lineText[col - 1] not in @[c'\t', c' ', c'[', c'(']
				triggerWordLength += 1
				col -= 1
		
		# return unique completion data entries
		dataSet = HashSet<of String>()
		
		uniqueData = List<of ICompletionData>()
		
		for region in containingRegions
			for d in _getCompletionData(region, preceedingText, "TODO", nodeMap)
				if dataSet.add(d.toString)
					uniqueData.add(d)
		
		completionData.addRange(uniqueData)

		if completionData.count <> 0
			return completionData
		else
			return nil


	def handleParameterCompletion(context as CodeCompletionContext?, completionChar as char) _
		as IParameterDataProvider? is override
		
		return nil
	
	def _isInsideComment(context as CodeCompletionContext) as bool
		"""
		Returns true if the cursor is inside a comment region.
		"""
		require
			.editor <> nil
			.document <> nil
			.document.parsedDocument <> nil
		body
			line = context.triggerLine
			col = context.triggerLineOffset
			if line < 1, line = 1
			if col < 0, col = 0
			
			lineText = .editor.getLineText(line) ? ""
			
			if _isInsideComment(line, col, lineText, .document.parsedDocument.foldings)
				return true
				
			# handle corner case with empty doc strings
			prevLineText = .editor.getLineText(line - 1) ? ""
			nextLineText = .editor.getLineText(line + 1) ? ""
			if prevLineText.endsWith('"""') and nextLineText.endsWith('"""')
				return true
			else if prevLineText.endsWith("'''") and nextLineText.endsWith("'''")
				return true
			
			return false
	
	def _isInsideComment(line as int, col as int, lineText as String, foldings as IEnumerable<of FoldingRegion>) as bool
		"""
		Returns true if the cursor is inside a comment region.
		"""
		require
			line > 0
			col >= 0
		test lineComment
			ext = CobraCompletionTextEditorExtension()
			folds = List<of FoldingRegion>()
			assert ext._isInsideComment(1, 0, "# comment", folds)
			assert ext._isInsideComment(1, 1, "# comment", folds)
			assert ext._isInsideComment(1, 15, "print 'hello' # comment", folds)
		test commentBlock
			ext = CobraCompletionTextEditorExtension()
			folds = List<of FoldingRegion>()
			folds.add(FoldingRegion(DomRegion(1, 1, 4, 1), FoldType.Comment))
			assert ext._isInsideComment(2, 1, "print '#hello#'", folds)
			folds.add(FoldingRegion(DomRegion(1, 1, 3, 1), FoldType.Undefined))
			assert ext._isInsideComment(2, 0, "print '#hello#'", folds)
		test notInComment
			ext = CobraCompletionTextEditorExtension()
			folds = List<of FoldingRegion>()
			assert not ext._isInsideComment(1, 0, "print 'hello' # comment", folds)
			assert not ext._isInsideComment(1, 1, "print 'hello' # comment", folds)
			assert not ext._isInsideComment(1, 10, "print '#hello#'", folds)
			folds.add(FoldingRegion(DomRegion(3, 1, 4, 1), FoldType.Comment))
			assert not ext._isInsideComment(1, 1, "print 'hello' # comment", folds)
			folds.add(FoldingRegion(DomRegion(1, 1, 2, 1), FoldType.Undefined))
			assert not ext._isInsideComment(1, 0, "print 'hello' # comment", folds)
		body
			if lineText.length > 0
				
				if lineText.trimStart.startsWith("#")
					return true
				
				inString = false
				stringDelim as char? = nil
				
				for i in 0:col
					c = lineText[i]
					if c == c'"' or c == c"'"
						if stringDelim == nil
							stringDelim = c
							inString = true
						else if stringDelim == c
							stringDelim = nil
							inString = false
					if c == c'#' and not inString
						return true
				
			for fold in foldings
				if fold.type == FoldType.Comment and fold.region.isInside(line, col)
					return true
				
			return false
	
	
	def _createNodeMap(regionMap as Dictionary<of ISyntaxNode, DomRegion>) as Dictionary<of DomRegion, ISyntaxNode>
		"""
		Returns a map of DomRegions to ISyntaxNodes given a map of ISyntaxNodes to DomRegions.
		"""
		ensure
			all for node in regionMap.keys get node in result.values
			all for region in regionMap.values get region in result.keys
		body
			nodeMap = Dictionary<of DomRegion, ISyntaxNode>()
			for node, region in regionMap
				nodeMap[region] = node
			return nodeMap
	

	def getContainingRegions(line as int, col as int, regions as DomRegion*) as List<of DomRegion>
		"""
		Returns a list of document regions from the given region stream that contain the 
		given document location.
		"""
		ensure # we'll never return more regions than what was given
			result.count <= List<of DomRegion>(regions).count
		test
			rs = List<of DomRegion>()
			rs.add(DomRegion(1, 1, 10, 120))
			rs.add(DomRegion(1, 1, 5, 120))
			rs.add(DomRegion(6, 1, 10, 120))
			rs.add(DomRegion(11, 1, 15, 120))
			rs.add(DomRegion(12,1, 14, 120))

			complExt = CobraCompletionTextEditorExtension()
			assert complExt.getContainingRegions(1, 1, rs).count == 2
			assert complExt.getContainingRegions(2, 1, rs).count == 2
			assert complExt.getContainingRegions(5, 80, rs).count == 2
			assert complExt.getContainingRegions(6, 10, rs).count == 2
			assert complExt.getContainingRegions(11, 1, rs).count == 1
			assert complExt.getContainingRegions(13, 1, rs).count == 2
			assert complExt.getContainingRegions(15, 20, rs).count == 1
			assert complExt.getContainingRegions(16, 1, rs).count == 0
		body
			containingRegions = List<of DomRegion>()
			for r in regions
				if r.isInside(line, col)
					containingRegions.add(r)

			return containingRegions
		
	
	def _getContainingBox(regions as IList<of DomRegion>, nodeMap as Dictionary<of DomRegion, ISyntaxNode>) as Box?
		"""
		Iterates through the given regions and returns the innermost containing Box.
		
		Returns nil if none of the corresponding nodes inherit from Box.
		"""
		require
			regions.count > 0
			all for region in regions get nodeMap.containsKey(region)
		body
			containingBox as Box? = nil
			innermostBeginLine = 0
			
			i = 0
			while i < regions.count
				region = regions[i]
				if region.beginLine > innermostBeginLine
					innermostBeginLine = region.beginLine
					node = nodeMap[region]
					if node inherits Box
						containingBox = node
				i += 1
			return containingBox
		
	def _extendRegions(regionMap as Dictionary<of ISyntaxNode, DomRegion>,
						symbolTable as Dictionary<of DomRegion, Dictionary<of String, INamedNode>?>)
		"""
		Extends the code regions in the given dictionaries to include blank lines.
		"""
		extendedRegionMap = Dictionary<of ISyntaxNode, DomRegion>()
		
		for node, region in regionMap
			
			extendedRegion = _extendRegion(region)
			extendedRegionMap[node] = extendedRegion
			
			idMap as Dictionary<of String, INamedNode>? = nil
			if symbolTable.tryGetValue(region, out idMap)
				symbolTable.remove(region)
				symbolTable[extendedRegion] = idMap
				
		for node, extendedRegion in extendedRegionMap
			regionMap[node] = extendedRegion
			
			
	def _extendRegion(region as DomRegion) as DomRegion
		"""
		Returns a copy of the given region but extends the last line
		to include all blank lines that immediately follow it.
		
		The ending point will be the 0th column of the first non-blank
		line.
		"""
		require
			.editor <> nil
			.editor.document <> nil
			region.beginLine > 0
		ensure
			result.beginLine == region.beginLine
			result.endLine >= region.endLine
		body
			textDoc = .editor.document
			beginText = textDoc.getLineText(region.beginLine) ? ""
			minIndentLevel = _getIndentLevel(beginText)
			fromLine = region.endLine + 1
			untilLine = textDoc.lineCount
			
			for line in fromLine:untilLine
				text = textDoc.getLineText(line)
				if text <> nil _
				and text.trim.length <> 0 _
				and _getIndentLevel(text to !) <= minIndentLevel
					break
			
			if line == textDoc.lineCount
				# special case for end of document
				col = Int32.maxValue
			else
				col = 0
			
			extendedRegion = DomRegion(region.fileName, _
			region.beginLine, region.beginColumn, _
			line, col)
			
			return extendedRegion

	def _getIndentLevel(line as String) as int
		"""
		Returns the number of indents for the given line.
		"""
		# Crap!  This function already exists in Parser.  Shouldn't be repeated here.
		return line.length - line.trimStart.length

	
	def _isInsideString(context as CodeCompletionContext) as bool
		"""
		Returns true if we should not provide code completion in the given
		context because we are inside a string literal and not inside
		[expression brackets].
		"""
		require
			.editor
			.editor.document
		body
			line = context.triggerLine
			col = context.triggerLineOffset
			if line < 1, line = 1
			if col < 0, col = 0
			
			lineText = .editor.document.getLineText(line) ? ""
			if col > lineText.length, col = lineText.length
			
			return _isInsideString(lineText.substring(0, col))
	
	
	def _isInsideString(text as String) as bool
		"""
		Returns true if we should not provide code completion in the given
		context because we are inside a string literal and not inside
		[expression brackets].
		"""
		test basics
			ext = CobraCompletionTextEditorExtension()
			assert ext._isInsideString("s = 'Hello, wo")
			assert ext._isInsideString('s = "Hello, wo')
			
			assert not ext._isInsideString("s = 'Hello, world!'")
			assert not ext._isInsideString('s = "Hello, world!"')
			assert not ext._isInsideString("print s")
		test expressionBrackets
			ext = CobraCompletionTextEditorExtension()
			assert ext._isInsideString(ns's = "a [b] c')
			assert not ext._isInsideString(ns's = "a [b')
			assert ext._isInsideString(ns's = ns"a [b')
		body
			tag as char? = nil
			quotes = @[c"'", c'"']
			inString = false
			inNonSubString = false
			inSubExpr = false
			
			i = 0
			while i < text.length
				character = text[i]
				
				if tag == nil
					if character in quotes
						# string opening tag
						tag = character
						inString = true
					else if character == c'n' and i + 2 < text.length
						if text[i+1] == c's' and text[i+2] in quotes
							# non-substituted string opening tag
							tag = text[i+2]
							inString = true
							inNonSubString = true
							i += 2
				else
					if character == tag
						# string closing tag
						inString = false
						inNonSubString = false
						tag = nil
					else if not inNonSubString
						if character == c'['
							inSubExpr = true
						else if inSubExpr and character == c']'
							inSubExpr = false
				i += 1
					
			if inNonSubString
				return true
			else if inSubExpr
				return false
			else
				return inString
	
	
	shared
		var rexIdentifier = Regex( _
			r'[_a-zA-z0-9]*', _
			RegexOptions.Compiled _
		)

	def _getIdsFromText(text as String) as List<of String>
		"""
		Given a line of text, returns a list of trailing identifiers.

		For example, given "foo = SomeSharedClass.someProp.", then this
		method would return ['SomeSharedClass', 'someProp'].
		"""
		test
			sampleText = "foo = SomeSharedClass.someProp."
			completionExtension = CobraCompletionTextEditorExtension()
			ids = completionExtension._getIdsFromText(sampleText)
			assert ids.count == 2
			assert ids[0] == "SomeSharedClass"
			assert ids[1] == "someProp"
		body
			ids = List<of String>()
			text = text.trim

			# split the text by whitespace
			pieces = text.split
			lastPiece = pieces[pieces.length - 1]

			match = CobraCompletionTextEditorExtension.rexIdentifier.match(lastPiece)
			while match.success
				if match.value.length > 0
					ids.add(match.value)
				match = match.nextMatch to !

			return ids

	def _getNodeFromIds(ids as List<of String>,
						containingRegions as List<of DomRegion>,
						symbolTable as Dictionary<of DomRegion, Dictionary<of String, INamedNode>>) as ISyntaxNode
		"""
		Given a list of identifiers, returns the syntax node in the AST
		corresponding to the last valid idenfiier.

		Throws an ArgumentException if no node is found.
		"""
		require
			ids.count > 0
			containingRegions.count > 0

		test singleIdentifier
			# setup
			ids = ['Object']
			regions = [DomRegion(1,1)]
			bogusNode = Class('Object', List<of Cobra.Compiler.IType>())
			symbolTable = Dictionary<of DomRegion, Dictionary<of String, INamedNode>>()
			symbolTable[regions[0]] = Dictionary<of String, INamedNode>()
			symbolTable[regions[0]]['Object'] = bogusNode

			# the test
			completionExtension = CobraCompletionTextEditorExtension()
			assert completionExtension._getNodeFromIds(ids, regions, symbolTable) is bogusNode
			
		test multipleIdentifiers
			#TODO
			# setup
			# the test
			pass

		body
			#TODO: still feels ugly...
			correspondingNode as ISyntaxNode? = nil
			idMap as Dictionary<of String, INamedNode>? = nil

			for region in containingRegions
				
				found = false

				if symbolTable.tryGetValue(region, out idMap)
				
					for id, node in idMap
					
						if id == ids[0]
							correspondingNode = node to ISyntaxNode
							found = true
							break
							
					if found, break
				if found, break
			
			if found
				# we found a node with this name, limit the rest of our search to this node
				return _getNodeFromIds(ids[1:ids.count], correspondingNode)
			
			throw ArgumentException()
			
	def _getNodeFromIds(ids as List<of String>, parent as ISyntaxNode) as ISyntaxNode
		"""
		Given a list of identifiers, returns the syntax node in the AST
		corresponding to the last valid idenfiier.

		Throws an ArgumentException if no node is found.
		"""
		if ids.count == 0
			return parent
		
		if parent implements INamedNode
		
			typ = parent.typeForReceiver
			if typ inherits NilableType
				typ = typ.nonNil
				
			if typ inherits PrimitiveType
				typ = typ.box
			else if typ inherits Cobra.Compiler.ArrayType
				typ = typ.box
			
			if typ implements IContainer
						
				if typ inherits NameSpace
					for useDirective in typ.useDirectives
						if useDirective.boundNameSpace <> nil
							nsMember = useDirective.boundNameSpace.memberForName(ids[0])
							if nsMember <> nil
								try
									return _getNodeFromIds(ids[1:ids.count], nsMember to ISyntaxNode)
								catch
									throw ArgumentException()
		
				m = typ.memberForName(ids[0])
				if m <> nil
					try
						return _getNodeFromIds(ids[1:ids.count], m to ISyntaxNode)
					catch
						throw ArgumentException()
			else
				print "[parent.typeForReceiver.name] does not implement IContainer"
				print "Add a case for [parent.typeForReceiver.toString]\n"
		
		throw ArgumentException()
	

	def _getCompletionData(region as DomRegion, preceedingText as String, currText as String,
							nodeMap as Dictionary<of DomRegion, ISyntaxNode>) as ICompletionDataList
		"""
		Returns completion data in the context of the given DomRegion.
		"""
		dataList = CompletionDataList()
		
		try
			node = nodeMap[region]
		catch
			print "ERROR! Couldn't resolve region to node: [region.toString]"
			return dataList
		
		if node inherits NameSpace
			# being inside a namespace means we have access to all the classes inside of it
			if node.name.startsWith("(top")
				dataList.addRange(DataFactory.keywordListTopLevel)
				dataList.addRange(DataFactory.keywordListCobraTypes)
				dataList.addRange(DataFactory.keywordListLiterals)
				ast = .ast
				if ast <> nil, dataList.addRange(DataFactory.createModuleDeclsList(ast))
			else
				dataList.addRange(NameSpaceDeclsList(node))
			
		else if node inherits Box
			# being inside a box gives us access to certain keywords
			dataList.addRange(DataFactory.keywordListInBox)
			
		else if node inherits AbstractMethod
			# being inside a method gives us access to all its local variables and more Cobra keywords
			dataList.addRange(DataFactory.keywordListInMethod)
			dataList.addRange(MethodVarsList(node))
		else
			print "TODO: handle this type of container: [node.toString]"
		
		return dataList
	

	shared
		def createTestData as CobraModule
			"""
			This function is only for supporting test methods.
			"""
			refs = List<of String>()
			cm = MonoDevelop.CobraBinding.CompilerManager.instance
			testData = MonoDevelop.CobraBinding.CompilerManager.readTestData("no_errors")

			for filePath, code in testData
				if filePath.endsWith("ForCompletionTesting.cobra")
					sourceMap = Dictionary<of String, String>()
					sourceMap[filePath] = code
					results = cm.parseAndBind(sourceMap, refs, filePath)
			for r in results
				if r inherits CobraModule
					return r
			
			throw FallThroughException()
