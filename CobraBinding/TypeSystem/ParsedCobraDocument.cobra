use Cobra.Compiler

use Mono.TextEditor

use MonoDevelop.Ide.TypeSystem

use ICSharpCode.NRefactory.TypeSystem

namespace MonoDevelop.CobraBinding.TypeSystem

class ParsedCobraDocument inherits DefaultParsedDocument

	test
		# default has no region/symbol data
		doc = ParsedCobraDocument("test.cobra", "pass")
		assert doc.regionMap == nil
		assert doc.symbolTable == nil
		nodeMap = doc.createNodeMap
		assert nodeMap == nil
		# when created from the compiler, we get meaningful data
		doc = .createTestData
		assert doc.regionMap.count == doc.symbolTable.count == 5
		nodeMap = doc.createNodeMap
		assert nodeMap <> nil

	var _content as String
	var _regionMap as Dictionary<of ISyntaxNode, DomRegion>?
	var _symbolTable as Dictionary<of DomRegion, Dictionary<of String, INamedNode>>?

	cue init(fileName as String, content as String)
		base.init(fileName)
		_content = content

	get content from var

	get regionMap from var

	get symbolTable from var
	
	def add(errors as SourceException*)
		for err in errors
			.add(err)
	
	def add(err as SourceException)
		col = err.colNum
		# most of the time, we don't get a valid column number for these.
		# but just in case...
		if col > 0, col -= 1
		.add(Error(ErrorType.Error, err.message, err.lineNum, col))
		
	def add(mod as CobraModule)
		.ast = mod
		visitor = CobraModuleVisitor()
		visitor.visit(mod)
		_regionMap = visitor.regionMap
		_symbolTable = visitor.symbolTable
		
	def createNodeMap as Dictionary<of DomRegion, ISyntaxNode>?
		"""
		Returns a map of DomRegions to ISyntaxNodes given a map of ISyntaxNodes to DomRegions.
		"""
		ensure
			_regionMap implies result
			_regionMap implies all for node in _regionMap.keys get node in result.values
			_regionMap implies all for region in _regionMap.values get region in result.keys
		body
			if _regionMap == nil, return nil
			nodeMap = Dictionary<of DomRegion, ISyntaxNode>()
			for node, region in _regionMap
				nodeMap[region] = node
			
			return nodeMap
			
	def getContainingRegions(line as int, col as int) as List<of DomRegion>
		"""
		Returns a list of document regions that contain the given document location.
		"""
		require
			_regionMap <> nil
		ensure # we'll never return more regions than what we have
			result.count <= _regionMap.values.count
		test
			doc = .createTestData
			assert doc.getContainingRegions(1, 1).count == 1
			assert doc.getContainingRegions(2, 1).count == 1
			assert doc.getContainingRegions(2, 20).count == 2
			assert doc.getContainingRegions(3, 1).count == 2
			assert doc.getContainingRegions(3, 8).count == 3
			assert doc.getContainingRegions(4, 10).count == 3
			assert doc.getContainingRegions(5, 1).count == 4
			assert doc.getContainingRegions(6, 1).count == 5
			assert doc.getContainingRegions(7, 1).count == 4 # region not extended yet
			assert doc.getContainingRegions(8, 20).count == 4
			assert doc.getContainingRegions(9, 1).count == 4
			assert doc.getContainingRegions(10, 1).count == 0 # region not extended yet
			assert doc.getContainingRegions(11, 1).count == 0 # line doesn't exist
		body
			containingRegions = List<of DomRegion>()
			for r in _regionMap.values
				if r.isInside(line, col)
					containingRegions.add(r)

			return containingRegions
			
	def extendRegions(txtDoc as TextDocument)
		"""
		Extends the code regions in the given dictionaries to include blank lines.
		"""
		require
			_regionMap <> nil
			_symbolTable <> nil
			.ast <> nil
		test
			doc = .createTestData
			txtDoc = TextDocument.createImmutableDocument(doc.content, true) to !
			doc.extendRegions(txtDoc)
			assert doc.getContainingRegions(1, 1).count == 1
			assert doc.getContainingRegions(2, 1).count == 1
			assert doc.getContainingRegions(2, 20).count == 2
			assert doc.getContainingRegions(3, 1).count == 2
			assert doc.getContainingRegions(3, 8).count == 3
			assert doc.getContainingRegions(4, 10).count == 3
			assert doc.getContainingRegions(5, 1).count == 4
			assert doc.getContainingRegions(6, 1).count == 5
			assert doc.getContainingRegions(7, 1).count == 5 # different
			assert doc.getContainingRegions(8, 20).count == 4
			assert doc.getContainingRegions(9, 1).count == 4
			assert doc.getContainingRegions(10, 1).count == 4 # different
			assert doc.getContainingRegions(11, 1).count == 0 # line doesn't exist
		body
			extendedRegionMap = Dictionary<of ISyntaxNode, DomRegion>()
			topNameSpace = .getAst<of CobraModule>.topNameSpace
			
			for node, region in _regionMap
				
				extendedRegion = _extendRegion(region, txtDoc)
				
				if node is topNameSpace
					# special case to make sure the top-level namespace
					# for the module encompasses all other regions
					extendedRegion = DomRegion(region.fileName,
					extendedRegion.beginLine, extendedRegion.beginColumn,
					extendedRegion.endLine, Int32.maxValue)
				
				extendedRegionMap[node] = extendedRegion
				
				idMap as Dictionary<of String, INamedNode>? = nil
				if _symbolTable.tryGetValue(region, out idMap)
					_symbolTable.remove(region)
					_symbolTable[extendedRegion] = idMap to !
					
			for node, extendedRegion in extendedRegionMap
				_regionMap[node] = extendedRegion


	def _extendRegion(region as DomRegion, txtDoc as TextDocument) as DomRegion
		"""
		Returns a copy of the given region but extends the last line
		to include all blank lines that immediately follow it.
		
		The ending point will be the 0th column of the first non-blank
		line.
		"""
		require
			region.beginLine > 0
		ensure
			result.beginLine == region.beginLine
			result.endLine >= region.endLine
		body
			beginText = txtDoc.getLineText(region.beginLine) ? ""
			minIndentLevel = Parser.getIndentLevel(beginText)
			fromLine = region.endLine + 1
			untilLine = txtDoc.lineCount
			
			for line in fromLine:untilLine
				text = txtDoc.getLineText(line)
				if text <> nil _
				and text.trim.length <> 0 _
				and Parser.getIndentLevel(text to !) <= minIndentLevel
					break
			
			if line == txtDoc.lineCount
				# special case for end of document
				col = Int32.maxValue - 1
			else
				col = 0
			
			extendedRegion = DomRegion(region.fileName, _
			region.beginLine, region.beginColumn, _
			line, col)
			
			return extendedRegion
			
	def resolveTextToNode(text as String, containingRegions as List<of DomRegion>) as ISyntaxNode?
		"""
		Parses the given line of text and returns the corresponding node from the AST.
		# TODO: Accept a document location instead
		"""
		ids = Parser.getIdsFromText(text)
		if ids.count == 0
			print "couldn't parse identifers from text [text]\n"
			return nil
		
		try
			return _getNodeFromIds(ids, containingRegions)
			
		catch ArgumentException
			# not a valid identifier
			print "couldn't resolve [ids] to a node\n"
			return nil


	def _getNodeFromIds(ids as List<of String>, containingRegions as List<of DomRegion>) as ISyntaxNode
		"""
		Given a list of identifiers, returns the syntax node in the AST
		corresponding to the last valid idenfiier.

		Throws an ArgumentException if no node is found.
		"""
		require
			_symbolTable <> nil
			ids.count > 0
			containingRegions.count > 0
		test
			doc = .createTestData
			regions = List<of DomRegion>()
			for r in doc._regionMap.values
				regions.add(r)
			
			node = doc._getNodeFromIds(["Object"], regions)
			assert (node to Box).memberForName("toString") <> nil
			
			node = doc._getNodeFromIds(["String", "copy"], regions)
			assert (node to Method).resultType.name == "String?"
			
			node = doc._getNodeFromIds(["Example", "TestClass", "main"], regions)
			assert (node to Method).statements[0] inherits PrintStmt
		body
			idMap as Dictionary<of String, INamedNode>? = nil
			for region in containingRegions
				if not _symbolTable.tryGetValue(region, out idMap)
					continue
				for id, node in idMap
					if id == ids[0]
						remainingIds = ids[1:ids.count]
						return _getNodeFromIds(remainingIds, node to ISyntaxNode)
			throw ArgumentException()
	
	
	def _getNodeFromIds(ids as List<of String>, parent as ISyntaxNode) as ISyntaxNode
		"""
		Given a list of identifiers, returns the syntax node in the AST
		corresponding to the last valid idenfiier.

		Throws an ArgumentException if no node is found.
		"""
		if ids.count == 0
			return parent
		
		if parent implements INamedNode
		
			typ = parent.typeForReceiver
			if typ inherits NilableType
				typ = typ.nonNil
				
			if typ inherits PrimitiveType
				typ = typ.box
			else if typ inherits Cobra.Compiler.ArrayType
				typ = typ.box
			
			if typ implements IContainer
						
				if typ inherits NameSpace
					for useDirective in typ.useDirectives
						if useDirective.boundNameSpace <> nil
							nsMember = useDirective.boundNameSpace.memberForName(ids[0])
							if nsMember <> nil
								try
									return _getNodeFromIds(ids[1:ids.count], nsMember to ISyntaxNode)
								catch
									throw ArgumentException()
		
				m = typ.memberForName(ids[0])
				if m <> nil
					try
						return _getNodeFromIds(ids[1:ids.count], m to ISyntaxNode)
					catch
						throw ArgumentException()
			else
				print "[parent.typeForReceiver.name] does not implement IContainer"
				print "Add a case for [parent.typeForReceiver.toString]\n"
		
		throw ArgumentException()

	shared
		def createTestData as ParsedCobraDocument
			"""
			This function is only for supporting test methods.
			"""
			fileName = "test.cobra"
			source = "\n" +
				"namespace Example\n" +
				"    class TestClass\n" +
				"        def main\n" +
				"            test\n" +
				"                assert true\n" +
				"\n" +
				"            body\n" +
				"                print 'derp'\n" +
				""
			cm = MonoDevelop.CobraBinding.CompilerManager.instance
			doc = cm.parseAndBind({fileName: source}, ["System.Core"], fileName)
			return doc